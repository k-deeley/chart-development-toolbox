<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>WindRoseChart</title>
<meta name="generator" content="MATLAB 25.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-01-11">
<meta name="DC.source" content="WindRoseChart.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<pre class="codeinput">
<span class="keyword">classdef</span> WindRoseChart &lt; Chart
    <span class="comment">%WINDROSECHART Chart for displaying speed and direction data on an</span>
    <span class="comment">%angular (polar) histogram.</span>

    <span class="comment">% Copyright 2018-2025 The MathWorks, Inc.</span>

    <span class="keyword">properties</span> ( Dependent )
        <span class="comment">% Wind data table, containing direction and speed values.</span>
        WindData<span class="typesection">(:, 2) table {mustBeWindData}</span>
        <span class="comment">% Bin edges for the speed data.</span>
        SpeedBinEdges<span class="typesection">(1, :) double {mustBeNonnegative}</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Dependent )</span>

    <span class="keyword">properties</span> ( SetAccess = private )
        <span class="comment">% Speed and direction observation counts in each bin.</span>
        ObservationCounts<span class="typesection">(:, :) double {mustBeInteger, mustBeNonnegative}</span>
        <span class="comment">% Percentage observation counts in each bin.</span>
        PercentageObservationCounts<span class="typesection">(:, :) double </span><span class="keyword">...</span>
            <span class="typesection">{mustBeInRange( PercentageObservationCounts, 0, 100 )}</span>
        <span class="comment">% Cumulative percentages in each bin (by wind direction).</span>
        CumulativePercentageObservationCounts<span class="typesection">(:, :) double </span><span class="keyword">...</span>
            <span class="typesection">{mustBeNonnegative, mustBeFinite}</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Dependent, SetAccess = private )</span>

    <span class="keyword">properties</span>
        <span class="comment">% Radial offset for the direction labels.</span>
        DirectionLabelOffset<span class="typesection">(1, 1) double {mustBeReal, mustBeFinite}</span> = 0.05
        <span class="comment">% Direction label font size.</span>
        DirectionLabelFontSize<span class="typesection">(1, 1) double </span><span class="keyword">...</span>
            <span class="typesection">{mustBeNonnegative, mustBeFinite}</span> = 10
        <span class="comment">% Direction label font weight.</span>
        DirectionLabelFontWeight<span class="typesection">(1, 1) string {mustBeFontWeight}</span> = <span class="string">"normal"</span>
        <span class="comment">% Direction label font angle.</span>
        DirectionLabelFontAngle<span class="typesection">(1, 1) string {mustBeFontAngle}</span> = <span class="string">"normal"</span>
        <span class="comment">% Direction label visibility.</span>
        DirectionLabelVisible<span class="typesection">(1, 1) matlab.lang.OnOffSwitchState </span>= <span class="string">"on"</span>
        <span class="comment">% Patch face transparency.</span>
        FaceAlpha<span class="typesection">(1, 1) double {mustBeInRange( FaceAlpha, 0, 1 )}</span> = 1
        <span class="comment">% Patch line width.</span>
        LineWidth<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 0.5
        <span class="comment">% Patch line style.</span>
        LineStyle<span class="typesection">(1, 1) string {mustBeLineStyle}</span> = <span class="string">"-"</span>
        <span class="comment">% Patch edge color.</span>
        EdgeColor <span class="typesection">{mustBeColor( EdgeColor, </span><span class="keyword">...</span>
            <span class="typesection">["flat", "none", "interp"] )}</span> = [0.5, 0.5, 0.5]
        <span class="comment">% Patch edge alpha.</span>
        EdgeAlpha<span class="typesection">(1, 1) double {mustBeInRange( EdgeAlpha, 0, 1 )}</span> = 1
        <span class="comment">% Backdrop color.</span>
        BackdropColor <span class="typesection">{validatecolor}</span> = [0.85, 0.85, 0.85]
        <span class="comment">% Backdrop line width.</span>
        BackdropLineWidth<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 0.5
        <span class="comment">% Backdrop line style.</span>
        BackdropLineStyle<span class="typesection">(1, 1) string {mustBeLineStyle}</span> = <span class="string">"-"</span>
        <span class="comment">% Radial label font size.</span>
        RadialLabelFontSize<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 8
        <span class="comment">% Radial label font weight.</span>
        RadialLabelFontWeight<span class="typesection">(1, 1) string {mustBeFontWeight}</span> = <span class="string">"normal"</span>
        <span class="comment">% Radial label font angle.</span>
        RadialLabelFontAngle<span class="typesection">(1, 1) string {mustBeFontAngle}</span> = <span class="string">"normal"</span>
        <span class="comment">% Radial label visibility.</span>
        RadialLabelVisible<span class="typesection">(1, 1) matlab.lang.OnOffSwitchState </span>= <span class="string">"on"</span>
        <span class="comment">% Legend location.</span>
        LegendLocation<span class="typesection">(1, 1) string {mustBeLegendLocation}</span> = <span class="keyword">...</span>
            <span class="string">"northeastoutside"</span>
        <span class="comment">% Legend orientation.</span>
        LegendOrientation<span class="typesection">(1, 1) string {mustBeMember( </span><span class="keyword">...</span>
            <span class="typesection">LegendOrientation, ["vertical", "horizontal"] )}</span>= <span class="string">"vertical"</span>
        <span class="comment">% Legend number of columns.</span>
        LegendNumColumns<span class="typesection">(1, 1) double {mustBeInteger, mustBePositive}</span> = 1
        <span class="comment">% Legend box.</span>
        LegendBox<span class="typesection">(1, 1) matlab.lang.OnOffSwitchState </span>= <span class="string">"off"</span>
        <span class="comment">% Legend color.</span>
        LegendColor <span class="typesection">{mustBeColor( LegendColor, "none" )}</span> = <span class="string">"none"</span>
        <span class="comment">% Legend visibility.</span>
        LegendVisible<span class="typesection">(1, 1) matlab.lang.OnOffSwitchState </span>= <span class="string">"on"</span>
        <span class="comment">% Legend edge color.</span>
        LegendEdgeColor <span class="typesection">{mustBeColor( </span><span class="keyword">...</span>
            <span class="typesection">LegendEdgeColor, "none" )}</span> = [0.15, 0.15, 0.15]
        <span class="comment">% Legend font angle.</span>
        LegendFontAngle<span class="typesection">(1, 1) string {mustBeFontAngle}</span> = <span class="string">"normal"</span>
        <span class="comment">% Legend font size.</span>
        LegendFontSize<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 9
        <span class="comment">% Legend font weight.</span>
        LegendFontWeight<span class="typesection">(1, 1) string {mustBeFontWeight}</span> = <span class="string">"normal"</span>
        <span class="comment">% Legend line width.</span>
        LegendLineWidth<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 0.5
        <span class="comment">% Legend title string.</span>
        LegendTitle<span class="typesection">(1, 1) string </span>= <span class="string">"Windspeed (m/s)"</span>
    <span class="keyword">end</span> <span class="comment">% properties</span>

    <span class="keyword">properties</span> ( Dependent )
        <span class="comment">% Angular direction in which to display the radial labels.</span>
        RadialLabelDirection<span class="typesection">(1, 1) string {mustBeDirection}</span>
        <span class="comment">% Patch face colors.</span>
        FaceColors<span class="typesection">(:, 3) double {mustBeInRange( FaceColors, 0, 1 )}</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Dependent )</span>

    <span class="keyword">properties</span> ( Access = private )
        <span class="comment">% Internal storage for the WindData property.</span>
        WindData_<span class="typesection">(:, 2) table {mustBeWindData}</span> = defaultWindData()
        <span class="comment">% Internal storage for the SpeedBinEdges property.</span>
        SpeedBinEdges_<span class="typesection">(1, :) double {mustBeNonnegative}</span> = [0:5:30, Inf]
        <span class="comment">% Internal angle for the radial text labels (clockwise from North).</span>
        RadialLabelAngle<span class="typesection">(1, 1) double </span><span class="keyword">...</span>
            <span class="typesection">{mustBeInRange( RadialLabelAngle, 0, 360 )}</span> = 135
        <span class="comment">% Minimum backdrop circle radius.</span>
        MinRadius<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 1
        <span class="comment">% Maximum backdrop circle radius.</span>
        MaxRadius<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 1
        <span class="comment">% Outer border value for the axis limits.</span>
        OuterBorder<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 1
        <span class="comment">% Radii of the backdrop circles.</span>
        CircleRadii<span class="typesection">(1, :) double {mustBePositive, mustBeFinite}</span> = 1
        <span class="comment">% Logical scalar specifying whether a computation is required.</span>
        ComputationRequired<span class="typesection">(1, 1) logical </span>= false
    <span class="keyword">end</span> <span class="comment">% properties ( Access = private )</span>

    <span class="keyword">properties</span> ( Access = private, Transient, NonCopyable )
        <span class="comment">% Chart axes.</span>
        Axes<span class="typesection">(:, 1) matlab.graphics.axis.Axes {mustBeScalarOrEmpty}</span>
        <span class="comment">% Axes legend.</span>
        Legend<span class="typesection">(:, 1) matlab.graphics.illustration.Legend </span><span class="keyword">...</span>
            <span class="typesection">{mustBeScalarOrEmpty}</span>
        <span class="comment">% Concentric circles used in the chart backdrop.</span>
        BackdropCircles<span class="typesection">(:, 1) matlab.graphics.primitive.Line</span>
        <span class="comment">% Angular rays used in the chart backdrop.</span>
        BackdropRays<span class="typesection">(:, 1) matlab.graphics.primitive.Line</span>
        <span class="comment">% Text labels indicating the radial percentanges.</span>
        RadialLabels<span class="typesection">(:, 1) matlab.graphics.primitive.Text</span>
        <span class="comment">% Text labels indicating the wind directions.</span>
        DirectionLabels<span class="typesection">(:, 1) matlab.graphics.primitive.Text</span>
        <span class="comment">% Patch objects for the angular histogram.</span>
        Patches<span class="typesection">(:, :) matlab.graphics.primitive.Patch</span>
        <span class="comment">% Text objects to display the bin data.</span>
        TextBoxes<span class="typesection">(:, :) matlab.graphics.primitive.Text</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Access = private, Transient, NonCopyable )</span>

    <span class="keyword">properties</span> ( Constant, GetAccess = private )
        <span class="comment">% Angles for the backdrop rays.</span>
        RayAngles<span class="typesection">(1, :) double </span><span class="keyword">...</span>
            <span class="typesection">{mustBeNonnegative, mustBeFinite}</span> = 0:22.5:337.5
        <span class="comment">% Lower and upper edges for the direction bins.</span>
        DirectionEdges<span class="typesection">(:, 2) double </span><span class="keyword">...</span>
            <span class="typesection">{mustBeReal, mustBeFinite}</span> = [355, 5:10:345; 5:10:355].'
        <span class="comment">% Direction bin centers.</span>
        DirectionBinCenters<span class="typesection">(:, 1) double </span><span class="keyword">...</span>
            <span class="typesection">{mustBeReal, mustBeFinite}</span> = 0:10:350
        <span class="comment">% Direction label text, counterclockwise from East (E).</span>
        DirectionLabelText<span class="typesection">(:, 1) string </span>= directionLabelText()
        <span class="comment">% Number of concentric circles in the chart's backdrop.</span>
        NumCircles<span class="typesection">(1, 1) double {mustBeInteger, mustBePositive}</span> = 10
        <span class="comment">% Wind direction / angle lookup.</span>
        DirectionLookup = dictionary( WindRoseChart.RayAngles, <span class="keyword">...</span>
            [<span class="string">"N"</span>, <span class="string">"NNE"</span>, <span class="string">"NE"</span>, <span class="string">"ENE"</span>, <span class="keyword">...</span>
            <span class="string">"E"</span>, <span class="string">"ESE"</span>, <span class="string">"SE"</span>, <span class="string">"SSE"</span>, <span class="keyword">...</span>
            <span class="string">"S"</span>, <span class="string">"SSW"</span>, <span class="string">"SW"</span>, <span class="string">"WSW"</span>, <span class="keyword">...</span>
            <span class="string">"W"</span>, <span class="string">"WNW"</span>, <span class="string">"NW"</span>, <span class="string">"NNW"</span>] )
    <span class="keyword">end</span> <span class="comment">% properties ( Constant, GetAccess = private )</span>

    <span class="keyword">properties</span> ( Constant, Hidden )
        <span class="comment">% Product dependencies.</span>
        Dependencies<span class="typesection">(1, :) string </span>= <span class="string">"MATLAB"</span>
        <span class="comment">% Description.</span>
        ShortDescription<span class="typesection">(1, 1) string </span>= <span class="string">"Display wind speed and "</span> + <span class="keyword">...</span>
            <span class="string">"direction data on a polar histogram"</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Constant, Hidden )</span>

    <span class="keyword">methods</span>

        <span class="keyword">function</span> value = get.WindData( obj )

            value = obj.WindData_;

        <span class="keyword">end</span> <span class="comment">% get.WindData</span>

        <span class="keyword">function</span> set.WindData( obj, value )

            <span class="comment">% Mark the chart for an update.</span>
            obj.ComputationRequired = true;

            <span class="comment">% Update the internal stored value.</span>
            obj.WindData_ = value;

            <span class="comment">% Update the observation counts and derived quantities.</span>
            obj.updateCounts()

        <span class="keyword">end</span> <span class="comment">% set.WindData</span>

        <span class="keyword">function</span> value = get.SpeedBinEdges( obj )

            value = obj.SpeedBinEdges_;

        <span class="keyword">end</span> <span class="comment">% get.SpeedBinEdges</span>

        <span class="keyword">function</span> set.SpeedBinEdges( obj, value )

            <span class="comment">% Check the new value.</span>
            assert( issorted( value, <span class="string">"strictascend"</span> ) &amp;&amp; <span class="keyword">...</span>
                numel( value ) &gt;= 2 &amp;&amp; value(1) == 0 &amp;&amp; <span class="keyword">...</span>
                value(end) == Inf, <span class="string">"WindRose:InvalidSpeedBinEdges"</span>, <span class="keyword">...</span>
                <span class="string">"The speed bin edge vector must be of the form "</span> + <span class="keyword">...</span>
                <span class="string">"[0, v(1), v(2), ..., v(n), Inf] where v(i) &lt; v(i+1)"</span> + <span class="keyword">...</span>
                <span class="string">" for i = 1, 2, ..., n-1."</span> )

            <span class="comment">% Mark the chart for an update.</span>
            obj.ComputationRequired = true;

            <span class="comment">% Update the internal stored value.</span>
            obj.SpeedBinEdges_ = value;

            <span class="comment">% Update the observation counts and derived quantities.</span>
            obj.updateCounts()

        <span class="keyword">end</span> <span class="comment">% set.SpeedBinEdges</span>

        <span class="keyword">function</span> value = get.RadialLabelDirection( obj )

            value = string( obj.DirectionLookup(obj.RadialLabelAngle) );

        <span class="keyword">end</span> <span class="comment">% get.RadialLabelDirection</span>

        <span class="keyword">function</span> set.RadialLabelDirection( obj, value )

            <span class="comment">% Perform a reverse lookup to determine the required angle</span>
            <span class="comment">% (clockwise from North).</span>
            directions = values( obj.DirectionLookup );
            obj.RadialLabelAngle = obj.RayAngles(directions == value);

            <span class="comment">% Update the labels.</span>
            obj.updateRadialLabels()

        <span class="keyword">end</span> <span class="comment">% set.RadialLabelDirection</span>

        <span class="keyword">function</span> set.DirectionLabelOffset( obj, value )

            <span class="comment">% Update the stored property.</span>
            obj.DirectionLabelOffset = value;

            <span class="comment">% Update the direction labels.</span>
            obj.updateDirectionLabels()

        <span class="keyword">end</span> <span class="comment">% set.DirectionLabelOffset</span>

        <span class="keyword">function</span> value = get.FaceColors( obj )

            value = vertcat( obj.Patches(1, :).FaceColor );

        <span class="keyword">end</span> <span class="comment">% get.FaceColors</span>

        <span class="keyword">function</span> set.FaceColors( obj, value )

            <span class="comment">% Check that the number of colors is correct.</span>
            numColors = height( value );
            assert( numColors == width( obj.Patches ), <span class="keyword">...</span>
                <span class="string">"WindRose:WrongNumberOfFaceColors"</span>, <span class="keyword">...</span>
                <span class="string">"The number of colors must match the number of "</span> + <span class="keyword">...</span>
                <span class="string">"speed bins."</span> )

            <span class="comment">% Update the patches.</span>
            <span class="keyword">for</span> k = 1:numColors
                set( obj.Patches(:, k), <span class="string">"FaceColor"</span>, value(k, :) )
            <span class="keyword">end</span> <span class="comment">% for</span>

        <span class="keyword">end</span> <span class="comment">% set.FaceColors</span>

    <span class="keyword">end</span> <span class="comment">% methods</span>

    <span class="keyword">methods</span>

        <span class="keyword">function</span> obj = WindRoseChart( namedArgs )
            <span class="comment">%WINDROSECHART Construct a WindRoseChart object, given optional</span>
            <span class="comment">%name-value arguments.</span>

            <span class="keyword">arguments</span> ( Input )
                namedArgs.?WindRoseChart
            <span class="keyword">end</span> <span class="comment">% arguments ( Input )</span>

            <span class="comment">% Set any user-defined properties.</span>
            set( obj, namedArgs )

        <span class="keyword">end</span> <span class="comment">% constructor</span>

        <span class="keyword">function</span> varargout = title( obj, varargin )

            [varargout{1:nargout}] = title( obj.Axes, varargin{:} );

        <span class="keyword">end</span> <span class="comment">% title</span>

    <span class="keyword">end</span> <span class="comment">% methods</span>

    <span class="keyword">methods</span> ( Access = protected )

        <span class="keyword">function</span> setup( obj )
            <span class="comment">%SETUP Initialize the chart graphics.</span>

            <span class="comment">% Create the chart's axes.</span>
            obj.Axes = axes( <span class="string">"Parent"</span>, obj.getLayout(), <span class="keyword">...</span>
                <span class="string">"DataAspectRatio"</span>, [1, 1, 1], <span class="keyword">...</span>
                <span class="string">"Interactions"</span>, [], <span class="keyword">...</span>
                <span class="string">"Visible"</span>, <span class="string">"off"</span> );

            <span class="comment">% Ensure the title is visible.</span>
            obj.Axes.Title.Visible = <span class="string">"on"</span>;

            <span class="comment">% Create the chart backdrop. This comprises the concentric</span>
            <span class="comment">% circles, the angular rays, the radial labels and the</span>
            <span class="comment">% direction labels.</span>

            <span class="comment">% Concentric circles.</span>
            <span class="keyword">for</span> k = 1:obj.NumCircles
                obj.BackdropCircles(k) = line( <span class="string">"Parent"</span>, obj.Axes, <span class="keyword">...</span>
                    <span class="string">"XData"</span>, NaN, <span class="keyword">...</span>
                    <span class="string">"YData"</span>, NaN, <span class="keyword">...</span>
                    <span class="string">"Color"</span>, obj.BackdropColor, <span class="keyword">...</span>
                    <span class="string">"HandleVisibility"</span>, <span class="string">"off"</span> );
            <span class="keyword">end</span> <span class="comment">% for</span>

            <span class="comment">% Angular rays.</span>
            nRays = numel( obj.RayAngles );
            <span class="keyword">for</span> k = 1:nRays
                obj.BackdropRays(k) = line( <span class="string">"Parent"</span>, obj.Axes, <span class="keyword">...</span>
                    <span class="string">"XData"</span>, NaN, <span class="keyword">...</span>
                    <span class="string">"YData"</span>, NaN, <span class="keyword">...</span>
                    <span class="string">"Color"</span>, obj.BackdropColor, <span class="keyword">...</span>
                    <span class="string">"HandleVisibility"</span>, <span class="string">"off"</span> );
            <span class="keyword">end</span> <span class="comment">% for</span>

            <span class="comment">% Create the text boxes containing the radial percentage</span>
            <span class="comment">% labels.</span>
            textX = NaN( obj.NumCircles, 1 );
            textY = textX;
            radialText = repmat( <span class="string">""</span>, obj.NumCircles, 1 );
            obj.RadialLabels = text( textX, textY, radialText, <span class="keyword">...</span>
                <span class="string">"Parent"</span>, obj.Axes, <span class="keyword">...</span>
                <span class="string">"HandleVisibility"</span>, <span class="string">"off"</span>, <span class="keyword">...</span>
                <span class="string">"HorizontalAlignment"</span>, <span class="string">"center"</span>, <span class="keyword">...</span>
                <span class="string">"VerticalAlignment"</span>, <span class="string">"middle"</span> );

            <span class="comment">% Create the text boxes containing the direction labels.</span>
            textX = NaN( size( obj.DirectionLabelText ) );
            textY = textX;
            obj.DirectionLabels = <span class="keyword">...</span>
                text( textX, textY, obj.DirectionLabelText, <span class="keyword">...</span>
                <span class="string">"Parent"</span>, obj.Axes, <span class="keyword">...</span>
                <span class="string">"HandleVisibility"</span>, <span class="string">"off"</span>, <span class="keyword">...</span>
                <span class="string">"HorizontalAlignment"</span>, <span class="string">"center"</span>, <span class="keyword">...</span>
                <span class="string">"VerticalAlignment"</span>, <span class="string">"middle"</span> );

            <span class="comment">% Create the histogram patches comprising the wind rose. Loop</span>
            <span class="comment">% over the number of direction bins and the number of speed</span>
            <span class="comment">% bins. For each of direction-speed bin, create a patch object.</span>
            <span class="comment">% Similarly, create the text boxes for the direction-speed</span>
            <span class="comment">% data.</span>
            numDirectionBins = numel( obj.DirectionBinCenters );
            numSpeedBins = numel( obj.SpeedBinEdges_ ) - 1;
            patchColors = parula( numSpeedBins );
            obj.Patches = repmat( patch( <span class="string">"Parent"</span>, [] ), <span class="keyword">...</span>
                numDirectionBins, numSpeedBins );
            obj.TextBoxes = repmat( text( <span class="string">"Parent"</span>, [] ), <span class="keyword">...</span>
                numDirectionBins, numSpeedBins );
            <span class="keyword">for</span> k1 = 1:numDirectionBins
                <span class="keyword">for</span> k2 = 1:numSpeedBins
                    obj.Patches(k1, k2) = patch( <span class="string">"Parent"</span>, obj.Axes, <span class="keyword">...</span>
                        <span class="string">"FaceColor"</span>, patchColors(k2, :), <span class="keyword">...</span>
                        <span class="string">"XData"</span>, NaN, <span class="keyword">...</span>
                        <span class="string">"YData"</span>, NaN, <span class="keyword">...</span>
                        <span class="string">"ButtonDownFcn"</span>, @obj.onPatchClicked );
                    obj.TextBoxes(k1, k2) = text( <span class="string">"Parent"</span>, obj.Axes, <span class="keyword">...</span>
                        <span class="string">"PickableParts"</span>, <span class="string">"none"</span>, <span class="keyword">...</span>
                        <span class="string">"HorizontalAlignment"</span>, <span class="string">"left"</span>, <span class="keyword">...</span>
                        <span class="string">"VerticalAlignment"</span>, <span class="string">"middle"</span>, <span class="keyword">...</span>
                        <span class="string">"LineWidth"</span>, 1.5, <span class="keyword">...</span>
                        <span class="string">"Visible"</span>, <span class="string">"off"</span> );
                <span class="keyword">end</span> <span class="comment">% for k2</span>
            <span class="keyword">end</span> <span class="comment">% for k1</span>

            <span class="comment">% Initialize the legend.</span>
            obj.Legend = legend( obj.Axes, obj.Patches(1, :) );

        <span class="keyword">end</span> <span class="comment">% setup</span>

        <span class="keyword">function</span> update( obj )
            <span class="comment">%UPDATE Refresh the chart graphics.</span>

            <span class="keyword">if</span> obj.ComputationRequired

                <span class="comment">% Hide any visible text boxes, if necessary.</span>
                set( obj.TextBoxes, <span class="string">"Visible"</span>, <span class="string">"off"</span> )

                <span class="comment">% Update the axes limits.</span>
                axis( obj.Axes, obj.OuterBorder * [-1, 1, -1, 1] )

                <span class="comment">% Move the title.</span>
                obj.Axes.Title.Position = obj.OuterBorder * [-1, 1, 0];

                <span class="comment">% Backdrop concentric circles.</span>
                t = linspace( 0, 2*pi ).';
                circleX = cos( t ) * obj.CircleRadii;
                circleY = sin( t ) * obj.CircleRadii;

                <span class="comment">% Update the circles' x and y-data.</span>
                <span class="keyword">for</span> k = 1:obj.NumCircles
                    set( obj.BackdropCircles(k), <span class="keyword">...</span>
                        <span class="string">"XData"</span>, circleX(:, k), <span class="string">"YData"</span>, circleY(:, k) )
                <span class="keyword">end</span> <span class="comment">% for</span>

                <span class="comment">% Backdrop angular rays. These begin at the inner circle</span>
                <span class="comment">% and terminate at the outer circle.</span>
                rayLims = [obj.MinRadius; obj.MinRadius + obj.MaxRadius];
                rayX = rayLims * cosd( obj.RayAngles );
                rayY = rayLims * sind( obj.RayAngles );
                <span class="keyword">for</span> k = 1:numel( obj.RayAngles )
                    set( obj.BackdropRays(k), <span class="string">"XData"</span>, rayX(:, k), <span class="keyword">...</span>
                        <span class="string">"YData"</span>, rayY(:, k) )
                <span class="keyword">end</span> <span class="comment">% for</span>

                <span class="comment">% Radial text labels.</span>
                obj.updateRadialLabels()

                <span class="comment">% Direction labels.</span>
                obj.updateDirectionLabels()

                <span class="comment">% Histogram patches and text boxes. First, determine</span>
                <span class="comment">% whether new objects need to be created or old objects</span>
                <span class="comment">% need to be deleted.</span>
                previousNumSpeedBins = width( obj.Patches );
                currentNumSpeedBins = numel( obj.SpeedBinEdges_ ) - 1;
                numDirectionBins = numel( obj.DirectionBinCenters );
                <span class="keyword">if</span> currentNumSpeedBins &lt; previousNumSpeedBins
                    <span class="comment">% Delete the graphics objects.</span>
                    delete( obj.Patches(:, currentNumSpeedBins+1:end) )
                    delete( obj.TextBoxes(:, currentNumSpeedBins+1:end) )
                    <span class="comment">% Update the stored properties.</span>
                    obj.Patches(:, currentNumSpeedBins+1:end) = [];
                    obj.TextBoxes(:, currentNumSpeedBins+1:end) = [];
                <span class="keyword">elseif</span> currentNumSpeedBins &gt;= previousNumSpeedBins
                    <span class="comment">% Create new patches and text boxes.</span>
                    obj.Patches(1:numDirectionBins, <span class="keyword">...</span>
                        previousNumSpeedBins+1:currentNumSpeedBins) = <span class="keyword">...</span>
                        patch( <span class="string">"Parent"</span>, [] );
                    obj.TextBoxes(1:numDirectionBins, <span class="keyword">...</span>
                        previousNumSpeedBins+1:currentNumSpeedBins) = <span class="keyword">...</span>
                        text( <span class="string">"Parent"</span>, [] );
                    <span class="keyword">for</span> k1 = 1 : height( obj.Patches )
                        <span class="keyword">for</span> k2 = previousNumSpeedBins+1:currentNumSpeedBins
                            obj.Patches(k1, k2) = patch( <span class="keyword">...</span>
                                <span class="string">"Parent"</span>, obj.Axes, <span class="keyword">...</span>
                                <span class="string">"XData"</span>, NaN, <span class="keyword">...</span>
                                <span class="string">"YData"</span>, NaN, <span class="keyword">...</span>
                                <span class="string">"ButtonDownFcn"</span>, @obj.onPatchClicked );
                            obj.TextBoxes(k1, k2) = text( <span class="keyword">...</span>
                                <span class="string">"Parent"</span>, obj.Axes, <span class="keyword">...</span>
                                <span class="string">"PickableParts"</span>, <span class="string">"none"</span>, <span class="keyword">...</span>
                                <span class="string">"HorizontalAlignment"</span>, <span class="string">"left"</span>, <span class="keyword">...</span>
                                <span class="string">"VerticalAlignment"</span>, <span class="string">"middle"</span>, <span class="keyword">...</span>
                                <span class="string">"BackgroundColor"</span>, <span class="string">"w"</span>, <span class="keyword">...</span>
                                <span class="string">"EdgeColor"</span>, <span class="string">"k"</span>, <span class="keyword">...</span>
                                <span class="string">"LineWidth"</span>, 1.5, <span class="keyword">...</span>
                                <span class="string">"Visible"</span>, <span class="string">"off"</span> );
                        <span class="keyword">end</span> <span class="comment">% for k2</span>
                    <span class="keyword">end</span> <span class="comment">% for k1</span>
                <span class="keyword">end</span> <span class="comment">% if</span>

                <span class="comment">% Update the patch x and y-data, as well as the face</span>
                <span class="comment">% colors. Use the same loop to update the text boxes.</span>
                angularSemiBinWidth = obj.DirectionEdges(1, 2);
                thetaBase = <span class="keyword">...</span>
                    linspace( -angularSemiBinWidth, angularSemiBinWidth );
                cpoc = obj.CumulativePercentageObservationCounts;
                [numDirectionBins, numSpeedBins] = size( cpoc );
                patchColors = parula( numSpeedBins );
                <span class="keyword">for</span> k1 = 1:numDirectionBins
                    <span class="keyword">for</span> k2 = 1:numSpeedBins
                        <span class="comment">% Inner radius.</span>
                        <span class="keyword">if</span> k2 &gt; 1
                            r(1) = cpoc(k1, k2-1);
                        <span class="keyword">else</span>
                            r(1) = 0;
                        <span class="keyword">end</span> <span class="comment">% if</span>
                        <span class="comment">% Outer radius.</span>
                        r(2) = cpoc(k1, k2);
                        r = r + obj.MinRadius;
                        <span class="comment">% Patch x and y coordinates.</span>
                        theta = obj.DirectionBinCenters(k1) + thetaBase;
                        patchX = [r(1) * sind( fliplr( theta ) ), <span class="keyword">...</span>
                            r(2) * sind( theta )];
                        patchY = [r(1) * cosd( fliplr( theta ) ), <span class="keyword">...</span>
                            r(2) * cosd( theta )];
                        set( obj.Patches(k1, k2), <span class="string">"XData"</span>, patchX, <span class="keyword">...</span>
                            <span class="string">"YData"</span>, patchY, <span class="keyword">...</span>
                            <span class="string">"FaceColor"</span>, patchColors(k2, :) )
                        <span class="comment">% Text boxes.</span>
                        set( obj.TextBoxes(k1, k2), <span class="string">"Position"</span>, <span class="keyword">...</span>
                            [mean( patchX ), mean( patchY ), 0], <span class="keyword">...</span>
                            <span class="string">"String"</span>, <span class="string">"{\bf{Direction Range:}} ["</span> + <span class="keyword">...</span>
                            obj.DirectionEdges(k1, 1) + char( 176 ) + <span class="keyword">...</span>
                            <span class="string">", "</span> + obj.DirectionEdges(k1, 2) + <span class="keyword">...</span>
                            char( 176 ) + <span class="string">")"</span> + newline() + <span class="keyword">...</span>
                            <span class="string">"{\bf{Observation Count:}} "</span> + sprintf( <span class="keyword">...</span>
                            <span class="string">"%d (%.2f%%)"</span>, <span class="keyword">...</span>
                            obj.ObservationCounts(k1, k2), <span class="keyword">...</span>
                            obj.PercentageObservationCounts(k1, k2) ) )
                    <span class="keyword">end</span> <span class="comment">% for k2</span>
                <span class="keyword">end</span> <span class="comment">% for k1</span>

                <span class="comment">% Ensure that all the text boxes are above all the patches</span>
                <span class="comment">% in the axes' visual stacking order.</span>
                obj.Axes.Children = [obj.TextBoxes(:); obj.Patches(:)];

                <span class="comment">% Update the legend, using only the first row of patches.</span>
                obj.Legend = legend( obj.Axes, obj.Patches(1, :) );

                <span class="comment">% Form legend text entries of the form "a &lt;= v &lt; b" for the</span>
                <span class="comment">% appropriate speed threshold values a and b.</span>
                legendText = strings( numSpeedBins, 1 );
                <span class="keyword">for</span> k = 1:numSpeedBins
                    legendText(k) = sprintf( <span class="string">"[%g, %g)"</span>, <span class="keyword">...</span>
                        obj.SpeedBinEdges(k), <span class="keyword">...</span>
                        obj.SpeedBinEdges(k+1) );
                <span class="keyword">end</span> <span class="comment">% for</span>
                obj.Legend.String = legendText;

                <span class="comment">% Mark the chart clean.</span>
                obj.ComputationRequired = false;

            <span class="keyword">end</span> <span class="comment">% if</span>

            <span class="comment">% Refresh the chart's decorative properties.</span>
            set( obj.Patches, <span class="keyword">...</span>
                <span class="string">"FaceAlpha"</span>, obj.FaceAlpha, <span class="keyword">...</span>
                <span class="string">"LineWidth"</span>, obj.LineWidth, <span class="keyword">...</span>
                <span class="string">"LineStyle"</span>, obj.LineStyle, <span class="keyword">...</span>
                <span class="string">"EdgeColor"</span>, obj.EdgeColor, <span class="keyword">...</span>
                <span class="string">"EdgeAlpha"</span>, obj.EdgeAlpha )
            set( [obj.BackdropCircles; obj.BackdropRays], <span class="keyword">...</span>
                <span class="string">"Color"</span>, obj.BackdropColor, <span class="keyword">...</span>
                <span class="string">"LineWidth"</span>, obj.BackdropLineWidth, <span class="keyword">...</span>
                <span class="string">"LineStyle"</span>, obj.BackdropLineStyle )
            set( obj.DirectionLabels, <span class="keyword">...</span>
                <span class="string">"FontSize"</span>, obj.DirectionLabelFontSize, <span class="keyword">...</span>
                <span class="string">"FontWeight"</span>, obj.DirectionLabelFontWeight, <span class="keyword">...</span>
                <span class="string">"FontAngle"</span>, obj.DirectionLabelFontAngle, <span class="keyword">...</span>
                <span class="string">"Visible"</span>, obj.DirectionLabelVisible )
            set( obj.RadialLabels, <span class="keyword">...</span>
                <span class="string">"FontSize"</span>, obj.RadialLabelFontSize, <span class="keyword">...</span>
                <span class="string">"FontWeight"</span>, obj.RadialLabelFontWeight, <span class="keyword">...</span>
                <span class="string">"FontAngle"</span>, obj.RadialLabelFontAngle, <span class="keyword">...</span>
                <span class="string">"Visible"</span>, obj.RadialLabelVisible )
            set( obj.Legend, <span class="keyword">...</span>
                <span class="string">"Location"</span>, obj.LegendLocation, <span class="keyword">...</span>
                <span class="string">"Orientation"</span>, obj.LegendOrientation, <span class="keyword">...</span>
                <span class="string">"NumColumns"</span>, obj.LegendNumColumns, <span class="keyword">...</span>
                <span class="string">"Color"</span>, obj.LegendColor, <span class="keyword">...</span>
                <span class="string">"Box"</span>, obj.LegendBox, <span class="keyword">...</span>
                <span class="string">"Visible"</span>, obj.LegendVisible, <span class="keyword">...</span>
                <span class="string">"EdgeColor"</span>, obj.LegendEdgeColor, <span class="keyword">...</span>
                <span class="string">"FontAngle"</span>, obj.LegendFontAngle, <span class="keyword">...</span>
                <span class="string">"FontSize"</span>, obj.LegendFontSize, <span class="keyword">...</span>
                <span class="string">"FontWeight"</span>, obj.LegendFontWeight, <span class="keyword">...</span>
                <span class="string">"LineWidth"</span>, obj.LegendLineWidth )
            obj.Legend.Title.String = obj.LegendTitle;

        <span class="keyword">end</span> <span class="comment">% update</span>

    <span class="keyword">end</span> <span class="comment">% methods ( Access = protected )</span>

    <span class="keyword">methods</span> ( Access = private )

        <span class="keyword">function</span> updateCounts( obj )
            <span class="comment">%UPDATECOUNTS Update the observation counts and derived</span>
            <span class="comment">%quantities.</span>

            <span class="comment">% Update the observation counts matrix. This has size pxq,</span>
            <span class="comment">% where p is the number of direction bins and q is the number</span>
            <span class="comment">% of speed bins. Each row corresponds to an angular direction</span>
            <span class="comment">% bin and each column corresponds to a windspeed bin. The</span>
            <span class="comment">% matrix elements are the number of data points in each</span>
            <span class="comment">% combined direction/speed bin.</span>
            numDirectionBins = numel( obj.DirectionBinCenters );
            numSpeedBins = numel( obj.SpeedBinEdges ) - 1;
            obj.ObservationCounts = <span class="keyword">...</span>
                zeros( numDirectionBins, numSpeedBins );
            windDirection = obj.WindData_.Direction;

            <span class="comment">% Loop over the direction bins. This computation is similar to</span>
            <span class="comment">% that performed by HISTCOUNTS2.</span>
            <span class="keyword">for</span> k = 1:numDirectionBins
                <span class="keyword">if</span> k == 1
                    <span class="comment">% The first direction bin is between 355 and 5 degrees,</span>
                    <span class="comment">% so requires different logic to the other direction</span>
                    <span class="comment">% bins (OR rather than AND).</span>
                    directionIdx = <span class="keyword">...</span>
                        windDirection &gt;= obj.DirectionEdges(k, 1) | <span class="keyword">...</span>
                        windDirection &lt;  obj.DirectionEdges(k, 2);
                <span class="keyword">else</span>
                    <span class="comment">% Otherwise, the directions come from a continuous</span>
                    <span class="comment">% interval.</span>
                    directionIdx = <span class="keyword">...</span>
                        windDirection &gt;= obj.DirectionEdges(k, 1) &amp; <span class="keyword">...</span>
                        windDirection &lt;  obj.DirectionEdges(k, 2);
                <span class="keyword">end</span> <span class="comment">% if</span>
                <span class="comment">% Extract the speeds in the current wind direction</span>
                <span class="comment">% interval, count them according to the speed bins.</span>
                obj.ObservationCounts(k, :) = <span class="keyword">...</span>
                    histcounts( obj.WindData_.Speed(directionIdx), <span class="keyword">...</span>
                    obj.SpeedBinEdges );
            <span class="keyword">end</span> <span class="comment">% for</span>

            <span class="comment">% Compute the percentage observation counts.</span>
            numObs = height( obj.WindData_ );
            obj.PercentageObservationCounts = 100 * <span class="keyword">...</span>
                obj.ObservationCounts / numObs;

            <span class="comment">% Compute the cumulative percentage observation counts by wind</span>
            <span class="comment">% direction.</span>
            obj.CumulativePercentageObservationCounts = cumsum( <span class="keyword">...</span>
                obj.PercentageObservationCounts, 2 );

            <span class="comment">% Update the radii and outer border.</span>
            obj.MaxRadius = ceil( max( <span class="keyword">...</span>
                obj.CumulativePercentageObservationCounts(:) ) );
            obj.MinRadius = obj.MaxRadius / 50;
            obj.OuterBorder = obj.MinRadius + obj.MaxRadius + 1;
            obj.CircleRadii = obj.MinRadius + (1:obj.NumCircles) * <span class="keyword">...</span>
                obj.MaxRadius / obj.NumCircles;

        <span class="keyword">end</span> <span class="comment">% updateCounts</span>

        <span class="keyword">function</span> updateRadialLabels( obj )
            <span class="comment">%UPDATERADIALLABELS Update the radial labels (position and</span>
            <span class="comment">%text). Note that the angle is converted from clockwise from</span>
            <span class="comment">%North to anticlockwise from East.</span>

            radTextX = sind( obj.RadialLabelAngle ) * obj.CircleRadii;
            radTextY = cosd( obj.RadialLabelAngle ) * obj.CircleRadii;
            radText = num2str( obj.CircleRadii(:), <span class="string">"%.1f%%"</span> );
            <span class="keyword">for</span> k = 1:numel( obj.RadialLabels )
                set( obj.RadialLabels(k), <span class="keyword">...</span>
                    <span class="string">"Position"</span>, [radTextX(k), radTextY(k), 0], <span class="keyword">...</span>
                    <span class="string">"String"</span>, radText(k, :) )
            <span class="keyword">end</span> <span class="comment">% for</span>

        <span class="keyword">end</span> <span class="comment">% updateRadialLabels</span>

        <span class="keyword">function</span> updateDirectionLabels( obj )
            <span class="comment">%UPDATEDIRECTIONLABELS Update the direction labels.</span>

            <span class="comment">% Define the radius at which to place the direction labels.</span>
            textRadius = obj.OuterBorder + obj.DirectionLabelOffset;

            <span class="comment">% Cartesian coordinates of the text labels.</span>
            textX = textRadius * cosd( obj.RayAngles );
            textY = textRadius * sind( obj.RayAngles );
            <span class="keyword">for</span> k = 1 : numel( obj.DirectionLabels )
                set( obj.DirectionLabels(k), <span class="keyword">...</span>
                    <span class="string">"Position"</span>, [textX(k), textY(k), 0] );
            <span class="keyword">end</span> <span class="comment">% for</span>

        <span class="keyword">end</span> <span class="comment">% updateDirectionLabels</span>

        <span class="keyword">function</span> onPatchClicked( obj, s, ~ )
            <span class="comment">%ONPATCHCLICKED Hide/show the bin data text box.</span>

            <span class="comment">% Identify the clicked patch.</span>
            clickedPatch = obj.Patches == s;

            <span class="comment">% Quickly flash the selected patch to provide visual feedback.</span>
            currentFaceColor = obj.Patches(clickedPatch).FaceColor;
            obj.Patches(clickedPatch).FaceColor = <span class="keyword">...</span>
                [1, 1, 1] - currentFaceColor;
            pause( 0.2 )
            obj.Patches(clickedPatch).FaceColor = currentFaceColor;

            <span class="comment">% Toggle the visibility of the corresponding text box.</span>
            obj.TextBoxes(clickedPatch).Visible = <span class="keyword">...</span>
                ~obj.TextBoxes(clickedPatch).Visible;

        <span class="keyword">end</span> <span class="comment">% onPatchClicked</span>

    <span class="keyword">end</span> <span class="comment">% methods ( Access = private )</span>

<span class="keyword">end</span> <span class="comment">% classdef</span>

<span class="keyword">function</span> windData = defaultWindData()
<span class="comment">%DEFAULTWINDDATA Create a default empty wind data table.</span>

Direction = double.empty( 0, 1 );
Speed = double.empty( 0, 1 );
windData = table( Direction, Speed );

<span class="keyword">end</span> <span class="comment">% defaultWindData</span>

<span class="keyword">function</span> mustBeWindData( t )
<span class="comment">%MUSTBEWINDDATA Verify that the 2-column table t contains valid windspeed</span>
<span class="comment">%and direction data.</span>

<span class="comment">% Check the table has the required variable names.</span>
varNames = t.Properties.VariableNames;
assert( isequal( sort( varNames ), [<span class="string">"Direction"</span>, <span class="string">"Speed"</span>] ), <span class="keyword">...</span>
    <span class="string">"WindRose:InvalidWindData"</span>, <span class="keyword">...</span>
    <span class="string">"The wind data must be specified as a table with two columns "</span> + <span class="keyword">...</span>
    <span class="string">"named Direction and Speed."</span> )

<span class="comment">% Check the windspeed and wind direction values.</span>
validateattributes( t.Speed, <span class="string">"double"</span>, <span class="keyword">...</span>
    [<span class="string">"column"</span>, <span class="string">"real"</span>, <span class="string">"finite"</span>, <span class="string">"nonnegative"</span>], <span class="keyword">...</span>
    <span class="string">"WindRose/mustBeWindData"</span>, <span class="string">"the windspeed data"</span> )
validateattributes( t.Direction, <span class="string">"double"</span>, <span class="keyword">...</span>
    {<span class="string">"column"</span>, <span class="string">"real"</span>, <span class="string">"finite"</span>, <span class="string">"nonnegative"</span>, <span class="string">"&lt;="</span>, 360}, <span class="keyword">...</span>
    <span class="string">"WindRose/mustBeWindData"</span>, <span class="string">"the wind direction data"</span> )

<span class="keyword">end</span> <span class="comment">% mustBeWindData</span>

<span class="keyword">function</span> labText = directionLabelText()
<span class="comment">%DIRECTIONLABELTEXT Direction label text, counterclockwise from East.</span>

angles = [90:-22.5:0, 337.5:-22.5:112.5];
labText = WindRoseChart.DirectionLookup(angles);

<span class="keyword">end</span> <span class="comment">% directionLabelText</span>

<span class="keyword">function</span> mustBeDirection( d )
<span class="comment">%MUSTBEDIRECTION Validate that the given direction is a member of the</span>
<span class="comment">%available directions.</span>

mustBeMember( d, values( WindRoseChart.DirectionLookup ) )

<span class="keyword">end</span> <span class="comment">% mustBeDirection</span>

<span class="keyword">function</span> mustBeLegendLocation( location )
<span class="comment">%MUSTBELEGENDLOCATION Validate that the given location is a member of the</span>
<span class="comment">%available legend locations.</span>

leg = matlab.graphics.illustration.Legend();
legendCleanup = onCleanup( @() delete( leg ) );
validLocations = set( leg, <span class="string">"Location"</span> );
mustBeMember( location, validLocations )

<span class="keyword">end</span> <span class="comment">% mustBeLegendLocation</span>

<span class="keyword">function</span> mustBeColor( c, opts )
<span class="comment">%MUSTBECOLOR Validate the given input, c, is a valid color or a member of</span>
<span class="comment">%the finite set of string options opts.</span>

c = convertCharsToStrings( c );
<span class="keyword">if</span> ~isstring( c ) || ~ismember( c, opts )
    validatecolor( c );
<span class="keyword">end</span> <span class="comment">% if</span>

<span class="keyword">end</span> <span class="comment">% mustBeColor</span>
</pre>
</div>
<!--
##### SOURCE BEGIN #####
classdef WindRoseChart < Chart
    %WINDROSECHART Chart for displaying speed and direction data on an
    %angular (polar) histogram.

    % Copyright 2018-2025 The MathWorks, Inc.

    properties ( Dependent )
        % Wind data table, containing direction and speed values.
        WindData(:, 2) table {mustBeWindData}
        % Bin edges for the speed data.
        SpeedBinEdges(1, :) double {mustBeNonnegative}
    end % properties ( Dependent )

    properties ( SetAccess = private )
        % Speed and direction observation counts in each bin.
        ObservationCounts(:, :) double {mustBeInteger, mustBeNonnegative}
        % Percentage observation counts in each bin.
        PercentageObservationCounts(:, :) double ...
            {mustBeInRange( PercentageObservationCounts, 0, 100 )}
        % Cumulative percentages in each bin (by wind direction).
        CumulativePercentageObservationCounts(:, :) double ...
            {mustBeNonnegative, mustBeFinite}
    end % properties ( Dependent, SetAccess = private )

    properties
        % Radial offset for the direction labels.
        DirectionLabelOffset(1, 1) double {mustBeReal, mustBeFinite} = 0.05
        % Direction label font size.
        DirectionLabelFontSize(1, 1) double ...
            {mustBeNonnegative, mustBeFinite} = 10
        % Direction label font weight.
        DirectionLabelFontWeight(1, 1) string {mustBeFontWeight} = "normal"
        % Direction label font angle.
        DirectionLabelFontAngle(1, 1) string {mustBeFontAngle} = "normal"
        % Direction label visibility.
        DirectionLabelVisible(1, 1) matlab.lang.OnOffSwitchState = "on"
        % Patch face transparency.
        FaceAlpha(1, 1) double {mustBeInRange( FaceAlpha, 0, 1 )} = 1
        % Patch line width.
        LineWidth(1, 1) double {mustBePositive, mustBeFinite} = 0.5
        % Patch line style.
        LineStyle(1, 1) string {mustBeLineStyle} = "-"
        % Patch edge color.
        EdgeColor {mustBeColor( EdgeColor, ...
            ["flat", "none", "interp"] )} = [0.5, 0.5, 0.5]
        % Patch edge alpha.
        EdgeAlpha(1, 1) double {mustBeInRange( EdgeAlpha, 0, 1 )} = 1
        % Backdrop color.
        BackdropColor {validatecolor} = [0.85, 0.85, 0.85]
        % Backdrop line width.
        BackdropLineWidth(1, 1) double {mustBePositive, mustBeFinite} = 0.5
        % Backdrop line style.
        BackdropLineStyle(1, 1) string {mustBeLineStyle} = "-"
        % Radial label font size.
        RadialLabelFontSize(1, 1) double {mustBePositive, mustBeFinite} = 8
        % Radial label font weight.
        RadialLabelFontWeight(1, 1) string {mustBeFontWeight} = "normal"
        % Radial label font angle.
        RadialLabelFontAngle(1, 1) string {mustBeFontAngle} = "normal"
        % Radial label visibility.
        RadialLabelVisible(1, 1) matlab.lang.OnOffSwitchState = "on"
        % Legend location.
        LegendLocation(1, 1) string {mustBeLegendLocation} = ...
            "northeastoutside"
        % Legend orientation.
        LegendOrientation(1, 1) string {mustBeMember( ...
            LegendOrientation, ["vertical", "horizontal"] )}= "vertical"
        % Legend number of columns.
        LegendNumColumns(1, 1) double {mustBeInteger, mustBePositive} = 1
        % Legend box.
        LegendBox(1, 1) matlab.lang.OnOffSwitchState = "off"
        % Legend color.
        LegendColor {mustBeColor( LegendColor, "none" )} = "none"
        % Legend visibility.
        LegendVisible(1, 1) matlab.lang.OnOffSwitchState = "on"
        % Legend edge color.
        LegendEdgeColor {mustBeColor( ...
            LegendEdgeColor, "none" )} = [0.15, 0.15, 0.15]
        % Legend font angle.
        LegendFontAngle(1, 1) string {mustBeFontAngle} = "normal"
        % Legend font size.
        LegendFontSize(1, 1) double {mustBePositive, mustBeFinite} = 9
        % Legend font weight.
        LegendFontWeight(1, 1) string {mustBeFontWeight} = "normal"
        % Legend line width.
        LegendLineWidth(1, 1) double {mustBePositive, mustBeFinite} = 0.5        
        % Legend title string.
        LegendTitle(1, 1) string = "Windspeed (m/s)"
    end % properties

    properties ( Dependent )
        % Angular direction in which to display the radial labels.
        RadialLabelDirection(1, 1) string {mustBeDirection}
        % Patch face colors.
        FaceColors(:, 3) double {mustBeInRange( FaceColors, 0, 1 )}
    end % properties ( Dependent )

    properties ( Access = private )
        % Internal storage for the WindData property.
        WindData_(:, 2) table {mustBeWindData} = defaultWindData()
        % Internal storage for the SpeedBinEdges property.
        SpeedBinEdges_(1, :) double {mustBeNonnegative} = [0:5:30, Inf]
        % Internal angle for the radial text labels (clockwise from North).
        RadialLabelAngle(1, 1) double ...
            {mustBeInRange( RadialLabelAngle, 0, 360 )} = 135
        % Minimum backdrop circle radius.
        MinRadius(1, 1) double {mustBePositive, mustBeFinite} = 1
        % Maximum backdrop circle radius.
        MaxRadius(1, 1) double {mustBePositive, mustBeFinite} = 1
        % Outer border value for the axis limits.
        OuterBorder(1, 1) double {mustBePositive, mustBeFinite} = 1
        % Radii of the backdrop circles.
        CircleRadii(1, :) double {mustBePositive, mustBeFinite} = 1
        % Logical scalar specifying whether a computation is required.
        ComputationRequired(1, 1) logical = false
    end % properties ( Access = private )

    properties ( Access = private, Transient, NonCopyable )
        % Chart axes.
        Axes(:, 1) matlab.graphics.axis.Axes {mustBeScalarOrEmpty}
        % Axes legend.
        Legend(:, 1) matlab.graphics.illustration.Legend ...
            {mustBeScalarOrEmpty}
        % Concentric circles used in the chart backdrop.
        BackdropCircles(:, 1) matlab.graphics.primitive.Line
        % Angular rays used in the chart backdrop.
        BackdropRays(:, 1) matlab.graphics.primitive.Line
        % Text labels indicating the radial percentanges.
        RadialLabels(:, 1) matlab.graphics.primitive.Text
        % Text labels indicating the wind directions.
        DirectionLabels(:, 1) matlab.graphics.primitive.Text
        % Patch objects for the angular histogram.
        Patches(:, :) matlab.graphics.primitive.Patch
        % Text objects to display the bin data.
        TextBoxes(:, :) matlab.graphics.primitive.Text
    end % properties ( Access = private, Transient, NonCopyable )

    properties ( Constant, GetAccess = private )
        % Angles for the backdrop rays.
        RayAngles(1, :) double ...
            {mustBeNonnegative, mustBeFinite} = 0:22.5:337.5
        % Lower and upper edges for the direction bins.
        DirectionEdges(:, 2) double ...
            {mustBeReal, mustBeFinite} = [355, 5:10:345; 5:10:355].'
        % Direction bin centers.
        DirectionBinCenters(:, 1) double ...
            {mustBeReal, mustBeFinite} = 0:10:350
        % Direction label text, counterclockwise from East (E).
        DirectionLabelText(:, 1) string = directionLabelText()
        % Number of concentric circles in the chart's backdrop.
        NumCircles(1, 1) double {mustBeInteger, mustBePositive} = 10
        % Wind direction / angle lookup.
        DirectionLookup = dictionary( WindRoseChart.RayAngles, ...
            ["N", "NNE", "NE", "ENE", ...
            "E", "ESE", "SE", "SSE", ...
            "S", "SSW", "SW", "WSW", ...
            "W", "WNW", "NW", "NNW"] )
    end % properties ( Constant, GetAccess = private )

    properties ( Constant, Hidden )
        % Product dependencies.
        Dependencies(1, :) string = "MATLAB"
        % Description.
        ShortDescription(1, 1) string = "Display wind speed and " + ...
            "direction data on a polar histogram"
    end % properties ( Constant, Hidden )

    methods

        function value = get.WindData( obj )

            value = obj.WindData_;

        end % get.WindData

        function set.WindData( obj, value )

            % Mark the chart for an update.
            obj.ComputationRequired = true;

            % Update the internal stored value.
            obj.WindData_ = value;

            % Update the observation counts and derived quantities.
            obj.updateCounts()

        end % set.WindData

        function value = get.SpeedBinEdges( obj )

            value = obj.SpeedBinEdges_;

        end % get.SpeedBinEdges

        function set.SpeedBinEdges( obj, value )

            % Check the new value.
            assert( issorted( value, "strictascend" ) && ...
                numel( value ) >= 2 && value(1) == 0 && ...
                value(end) == Inf, "WindRose:InvalidSpeedBinEdges", ...
                "The speed bin edge vector must be of the form " + ...
                "[0, v(1), v(2), ..., v(n), Inf] where v(i) < v(i+1)" + ...
                " for i = 1, 2, ..., n-1." )

            % Mark the chart for an update.
            obj.ComputationRequired = true;

            % Update the internal stored value.
            obj.SpeedBinEdges_ = value;

            % Update the observation counts and derived quantities.
            obj.updateCounts()

        end % set.SpeedBinEdges

        function value = get.RadialLabelDirection( obj )

            value = string( obj.DirectionLookup(obj.RadialLabelAngle) );

        end % get.RadialLabelDirection

        function set.RadialLabelDirection( obj, value )

            % Perform a reverse lookup to determine the required angle
            % (clockwise from North).            
            directions = values( obj.DirectionLookup );
            obj.RadialLabelAngle = obj.RayAngles(directions == value);

            % Update the labels.
            obj.updateRadialLabels()

        end % set.RadialLabelDirection

        function set.DirectionLabelOffset( obj, value )

            % Update the stored property.
            obj.DirectionLabelOffset = value;

            % Update the direction labels.
            obj.updateDirectionLabels()

        end % set.DirectionLabelOffset

        function value = get.FaceColors( obj )

            value = vertcat( obj.Patches(1, :).FaceColor );

        end % get.FaceColors

        function set.FaceColors( obj, value )

            % Check that the number of colors is correct.
            numColors = height( value );
            assert( numColors == width( obj.Patches ), ...
                "WindRose:WrongNumberOfFaceColors", ...
                "The number of colors must match the number of " + ...
                "speed bins." )

            % Update the patches.
            for k = 1:numColors
                set( obj.Patches(:, k), "FaceColor", value(k, :) )
            end % for

        end % set.FaceColors

    end % methods

    methods

        function obj = WindRoseChart( namedArgs )
            %WINDROSECHART Construct a WindRoseChart object, given optional
            %name-value arguments.

            arguments ( Input )
                namedArgs.?WindRoseChart
            end % arguments ( Input )

            % Set any user-defined properties.
            set( obj, namedArgs )

        end % constructor

        function varargout = title( obj, varargin )

            [varargout{1:nargout}] = title( obj.Axes, varargin{:} );

        end % title

    end % methods

    methods ( Access = protected )

        function setup( obj )
            %SETUP Initialize the chart graphics.

            % Create the chart's axes.
            obj.Axes = axes( "Parent", obj.getLayout(), ...
                "DataAspectRatio", [1, 1, 1], ...
                "Interactions", [], ...
                "Visible", "off" );

            % Ensure the title is visible.
            obj.Axes.Title.Visible = "on";

            % Create the chart backdrop. This comprises the concentric
            % circles, the angular rays, the radial labels and the
            % direction labels.

            % Concentric circles.
            for k = 1:obj.NumCircles
                obj.BackdropCircles(k) = line( "Parent", obj.Axes, ...
                    "XData", NaN, ...
                    "YData", NaN, ...
                    "Color", obj.BackdropColor, ...
                    "HandleVisibility", "off" );
            end % for

            % Angular rays.
            nRays = numel( obj.RayAngles );
            for k = 1:nRays
                obj.BackdropRays(k) = line( "Parent", obj.Axes, ...
                    "XData", NaN, ...
                    "YData", NaN, ...
                    "Color", obj.BackdropColor, ...
                    "HandleVisibility", "off" );
            end % for

            % Create the text boxes containing the radial percentage
            % labels.
            textX = NaN( obj.NumCircles, 1 );
            textY = textX;
            radialText = repmat( "", obj.NumCircles, 1 );
            obj.RadialLabels = text( textX, textY, radialText, ...
                "Parent", obj.Axes, ...
                "HandleVisibility", "off", ...
                "HorizontalAlignment", "center", ...
                "VerticalAlignment", "middle" );

            % Create the text boxes containing the direction labels.
            textX = NaN( size( obj.DirectionLabelText ) );
            textY = textX;
            obj.DirectionLabels = ...
                text( textX, textY, obj.DirectionLabelText, ...
                "Parent", obj.Axes, ...
                "HandleVisibility", "off", ...
                "HorizontalAlignment", "center", ...
                "VerticalAlignment", "middle" );

            % Create the histogram patches comprising the wind rose. Loop
            % over the number of direction bins and the number of speed
            % bins. For each of direction-speed bin, create a patch object.
            % Similarly, create the text boxes for the direction-speed
            % data.
            numDirectionBins = numel( obj.DirectionBinCenters );
            numSpeedBins = numel( obj.SpeedBinEdges_ ) - 1;
            patchColors = parula( numSpeedBins );
            obj.Patches = repmat( patch( "Parent", [] ), ...
                numDirectionBins, numSpeedBins );
            obj.TextBoxes = repmat( text( "Parent", [] ), ...
                numDirectionBins, numSpeedBins );
            for k1 = 1:numDirectionBins
                for k2 = 1:numSpeedBins
                    obj.Patches(k1, k2) = patch( "Parent", obj.Axes, ...
                        "FaceColor", patchColors(k2, :), ...
                        "XData", NaN, ...
                        "YData", NaN, ...
                        "ButtonDownFcn", @obj.onPatchClicked );
                    obj.TextBoxes(k1, k2) = text( "Parent", obj.Axes, ...
                        "PickableParts", "none", ...
                        "HorizontalAlignment", "left", ...
                        "VerticalAlignment", "middle", ...                       
                        "LineWidth", 1.5, ...
                        "Visible", "off" );
                end % for k2
            end % for k1

            % Initialize the legend.
            obj.Legend = legend( obj.Axes, obj.Patches(1, :) );

        end % setup

        function update( obj )
            %UPDATE Refresh the chart graphics.

            if obj.ComputationRequired

                % Hide any visible text boxes, if necessary.
                set( obj.TextBoxes, "Visible", "off" )

                % Update the axes limits.
                axis( obj.Axes, obj.OuterBorder * [-1, 1, -1, 1] )

                % Move the title.
                obj.Axes.Title.Position = obj.OuterBorder * [-1, 1, 0];

                % Backdrop concentric circles.
                t = linspace( 0, 2*pi ).';
                circleX = cos( t ) * obj.CircleRadii;
                circleY = sin( t ) * obj.CircleRadii;

                % Update the circles' x and y-data.
                for k = 1:obj.NumCircles
                    set( obj.BackdropCircles(k), ...
                        "XData", circleX(:, k), "YData", circleY(:, k) )
                end % for

                % Backdrop angular rays. These begin at the inner circle
                % and terminate at the outer circle.
                rayLims = [obj.MinRadius; obj.MinRadius + obj.MaxRadius];
                rayX = rayLims * cosd( obj.RayAngles );
                rayY = rayLims * sind( obj.RayAngles );
                for k = 1:numel( obj.RayAngles )
                    set( obj.BackdropRays(k), "XData", rayX(:, k), ...
                        "YData", rayY(:, k) )
                end % for

                % Radial text labels.
                obj.updateRadialLabels()

                % Direction labels.
                obj.updateDirectionLabels()

                % Histogram patches and text boxes. First, determine
                % whether new objects need to be created or old objects
                % need to be deleted.
                previousNumSpeedBins = width( obj.Patches );
                currentNumSpeedBins = numel( obj.SpeedBinEdges_ ) - 1;
                numDirectionBins = numel( obj.DirectionBinCenters );
                if currentNumSpeedBins < previousNumSpeedBins
                    % Delete the graphics objects.
                    delete( obj.Patches(:, currentNumSpeedBins+1:end) )
                    delete( obj.TextBoxes(:, currentNumSpeedBins+1:end) )
                    % Update the stored properties.
                    obj.Patches(:, currentNumSpeedBins+1:end) = [];
                    obj.TextBoxes(:, currentNumSpeedBins+1:end) = [];
                elseif currentNumSpeedBins >= previousNumSpeedBins
                    % Create new patches and text boxes.
                    obj.Patches(1:numDirectionBins, ...
                        previousNumSpeedBins+1:currentNumSpeedBins) = ...
                        patch( "Parent", [] );
                    obj.TextBoxes(1:numDirectionBins, ...
                        previousNumSpeedBins+1:currentNumSpeedBins) = ...
                        text( "Parent", [] );
                    for k1 = 1 : height( obj.Patches )
                        for k2 = previousNumSpeedBins+1:currentNumSpeedBins
                            obj.Patches(k1, k2) = patch( ...
                                "Parent", obj.Axes, ...
                                "XData", NaN, ...
                                "YData", NaN, ...
                                "ButtonDownFcn", @obj.onPatchClicked );
                            obj.TextBoxes(k1, k2) = text( ...
                                "Parent", obj.Axes, ...
                                "PickableParts", "none", ...
                                "HorizontalAlignment", "left", ...
                                "VerticalAlignment", "middle", ...
                                "BackgroundColor", "w", ...
                                "EdgeColor", "k", ...
                                "LineWidth", 1.5, ...
                                "Visible", "off" );
                        end % for k2
                    end % for k1
                end % if

                % Update the patch x and y-data, as well as the face
                % colors. Use the same loop to update the text boxes.
                angularSemiBinWidth = obj.DirectionEdges(1, 2);
                thetaBase = ...
                    linspace( -angularSemiBinWidth, angularSemiBinWidth );
                cpoc = obj.CumulativePercentageObservationCounts;
                [numDirectionBins, numSpeedBins] = size( cpoc );
                patchColors = parula( numSpeedBins );
                for k1 = 1:numDirectionBins
                    for k2 = 1:numSpeedBins
                        % Inner radius.
                        if k2 > 1
                            r(1) = cpoc(k1, k2-1);
                        else
                            r(1) = 0;
                        end % if
                        % Outer radius.
                        r(2) = cpoc(k1, k2);
                        r = r + obj.MinRadius;
                        % Patch x and y coordinates.
                        theta = obj.DirectionBinCenters(k1) + thetaBase;
                        patchX = [r(1) * sind( fliplr( theta ) ), ...
                            r(2) * sind( theta )];
                        patchY = [r(1) * cosd( fliplr( theta ) ), ...
                            r(2) * cosd( theta )];
                        set( obj.Patches(k1, k2), "XData", patchX, ...
                            "YData", patchY, ...
                            "FaceColor", patchColors(k2, :) )
                        % Text boxes.
                        set( obj.TextBoxes(k1, k2), "Position", ...
                            [mean( patchX ), mean( patchY ), 0], ...
                            "String", "{\bf{Direction Range:}} [" + ...
                            obj.DirectionEdges(k1, 1) + char( 176 ) + ...
                            ", " + obj.DirectionEdges(k1, 2) + ...
                            char( 176 ) + ")" + newline() + ...
                            "{\bf{Observation Count:}} " + sprintf( ...
                            "%d (%.2f%%)", ...
                            obj.ObservationCounts(k1, k2), ...
                            obj.PercentageObservationCounts(k1, k2) ) )
                    end % for k2
                end % for k1

                % Ensure that all the text boxes are above all the patches
                % in the axes' visual stacking order.
                obj.Axes.Children = [obj.TextBoxes(:); obj.Patches(:)];

                % Update the legend, using only the first row of patches.
                obj.Legend = legend( obj.Axes, obj.Patches(1, :) );

                % Form legend text entries of the form "a <= v < b" for the
                % appropriate speed threshold values a and b.
                legendText = strings( numSpeedBins, 1 );
                for k = 1:numSpeedBins
                    legendText(k) = sprintf( "[%g, %g)", ...
                        obj.SpeedBinEdges(k), ...
                        obj.SpeedBinEdges(k+1) );
                end % for
                obj.Legend.String = legendText;

                % Mark the chart clean.
                obj.ComputationRequired = false;

            end % if

            % Refresh the chart's decorative properties.
            set( obj.Patches, ...
                "FaceAlpha", obj.FaceAlpha, ...
                "LineWidth", obj.LineWidth, ...
                "LineStyle", obj.LineStyle, ...
                "EdgeColor", obj.EdgeColor, ...
                "EdgeAlpha", obj.EdgeAlpha )
            set( [obj.BackdropCircles; obj.BackdropRays], ...
                "Color", obj.BackdropColor, ...
                "LineWidth", obj.BackdropLineWidth, ...
                "LineStyle", obj.BackdropLineStyle )
            set( obj.DirectionLabels, ...
                "FontSize", obj.DirectionLabelFontSize, ...
                "FontWeight", obj.DirectionLabelFontWeight, ...
                "FontAngle", obj.DirectionLabelFontAngle, ...
                "Visible", obj.DirectionLabelVisible )
            set( obj.RadialLabels, ...
                "FontSize", obj.RadialLabelFontSize, ...
                "FontWeight", obj.RadialLabelFontWeight, ...
                "FontAngle", obj.RadialLabelFontAngle, ...
                "Visible", obj.RadialLabelVisible )
            set( obj.Legend, ...
                "Location", obj.LegendLocation, ...
                "Orientation", obj.LegendOrientation, ...
                "NumColumns", obj.LegendNumColumns, ...
                "Color", obj.LegendColor, ...
                "Box", obj.LegendBox, ...
                "Visible", obj.LegendVisible, ...
                "EdgeColor", obj.LegendEdgeColor, ...
                "FontAngle", obj.LegendFontAngle, ...
                "FontSize", obj.LegendFontSize, ...
                "FontWeight", obj.LegendFontWeight, ...
                "LineWidth", obj.LegendLineWidth )
            obj.Legend.Title.String = obj.LegendTitle;

        end % update

    end % methods ( Access = protected )

    methods ( Access = private )

        function updateCounts( obj )
            %UPDATECOUNTS Update the observation counts and derived
            %quantities.

            % Update the observation counts matrix. This has size pxq,
            % where p is the number of direction bins and q is the number
            % of speed bins. Each row corresponds to an angular direction
            % bin and each column corresponds to a windspeed bin. The
            % matrix elements are the number of data points in each
            % combined direction/speed bin.
            numDirectionBins = numel( obj.DirectionBinCenters );
            numSpeedBins = numel( obj.SpeedBinEdges ) - 1;
            obj.ObservationCounts = ...
                zeros( numDirectionBins, numSpeedBins );
            windDirection = obj.WindData_.Direction;

            % Loop over the direction bins. This computation is similar to
            % that performed by HISTCOUNTS2.
            for k = 1:numDirectionBins
                if k == 1
                    % The first direction bin is between 355 and 5 degrees,
                    % so requires different logic to the other direction
                    % bins (OR rather than AND).
                    directionIdx = ...
                        windDirection >= obj.DirectionEdges(k, 1) | ...
                        windDirection <  obj.DirectionEdges(k, 2);
                else
                    % Otherwise, the directions come from a continuous
                    % interval.
                    directionIdx = ...
                        windDirection >= obj.DirectionEdges(k, 1) & ...
                        windDirection <  obj.DirectionEdges(k, 2);
                end % if
                % Extract the speeds in the current wind direction
                % interval, count them according to the speed bins.
                obj.ObservationCounts(k, :) = ...
                    histcounts( obj.WindData_.Speed(directionIdx), ...
                    obj.SpeedBinEdges );
            end % for

            % Compute the percentage observation counts.
            numObs = height( obj.WindData_ );
            obj.PercentageObservationCounts = 100 * ...
                obj.ObservationCounts / numObs;

            % Compute the cumulative percentage observation counts by wind
            % direction.
            obj.CumulativePercentageObservationCounts = cumsum( ...
                obj.PercentageObservationCounts, 2 );

            % Update the radii and outer border.
            obj.MaxRadius = ceil( max( ...
                obj.CumulativePercentageObservationCounts(:) ) );
            obj.MinRadius = obj.MaxRadius / 50;
            obj.OuterBorder = obj.MinRadius + obj.MaxRadius + 1;
            obj.CircleRadii = obj.MinRadius + (1:obj.NumCircles) * ...
                obj.MaxRadius / obj.NumCircles;

        end % updateCounts

        function updateRadialLabels( obj )
            %UPDATERADIALLABELS Update the radial labels (position and
            %text). Note that the angle is converted from clockwise from
            %North to anticlockwise from East.

            radTextX = sind( obj.RadialLabelAngle ) * obj.CircleRadii;
            radTextY = cosd( obj.RadialLabelAngle ) * obj.CircleRadii;
            radText = num2str( obj.CircleRadii(:), "%.1f%%" );
            for k = 1:numel( obj.RadialLabels )
                set( obj.RadialLabels(k), ...
                    "Position", [radTextX(k), radTextY(k), 0], ...
                    "String", radText(k, :) )
            end % for

        end % updateRadialLabels

        function updateDirectionLabels( obj )
            %UPDATEDIRECTIONLABELS Update the direction labels.

            % Define the radius at which to place the direction labels.
            textRadius = obj.OuterBorder + obj.DirectionLabelOffset;

            % Cartesian coordinates of the text labels.
            textX = textRadius * cosd( obj.RayAngles );
            textY = textRadius * sind( obj.RayAngles );
            for k = 1 : numel( obj.DirectionLabels )
                set( obj.DirectionLabels(k), ...
                    "Position", [textX(k), textY(k), 0] );
            end % for

        end % updateDirectionLabels

        function onPatchClicked( obj, s, ~ )
            %ONPATCHCLICKED Hide/show the bin data text box.

            % Identify the clicked patch.
            clickedPatch = obj.Patches == s;

            % Quickly flash the selected patch to provide visual feedback.
            currentFaceColor = obj.Patches(clickedPatch).FaceColor;
            obj.Patches(clickedPatch).FaceColor = ...
                [1, 1, 1] - currentFaceColor;
            pause( 0.2 )
            obj.Patches(clickedPatch).FaceColor = currentFaceColor;

            % Toggle the visibility of the corresponding text box.
            obj.TextBoxes(clickedPatch).Visible = ...
                ~obj.TextBoxes(clickedPatch).Visible;

        end % onPatchClicked

    end % methods ( Access = private )

end % classdef

function windData = defaultWindData()
%DEFAULTWINDDATA Create a default empty wind data table.

Direction = double.empty( 0, 1 );
Speed = double.empty( 0, 1 );
windData = table( Direction, Speed );

end % defaultWindData

function mustBeWindData( t )
%MUSTBEWINDDATA Verify that the 2-column table t contains valid windspeed
%and direction data.

% Check the table has the required variable names.
varNames = t.Properties.VariableNames;
assert( isequal( sort( varNames ), ["Direction", "Speed"] ), ...
    "WindRose:InvalidWindData", ...
    "The wind data must be specified as a table with two columns " + ...
    "named Direction and Speed." )

% Check the windspeed and wind direction values.
validateattributes( t.Speed, "double", ...
    ["column", "real", "finite", "nonnegative"], ...
    "WindRose/mustBeWindData", "the windspeed data" )
validateattributes( t.Direction, "double", ...
    {"column", "real", "finite", "nonnegative", "<=", 360}, ...
    "WindRose/mustBeWindData", "the wind direction data" )

end % mustBeWindData

function labText = directionLabelText()
%DIRECTIONLABELTEXT Direction label text, counterclockwise from East.

angles = [90:-22.5:0, 337.5:-22.5:112.5];
labText = WindRoseChart.DirectionLookup(angles);

end % directionLabelText

function mustBeDirection( d )
%MUSTBEDIRECTION Validate that the given direction is a member of the
%available directions.

mustBeMember( d, values( WindRoseChart.DirectionLookup ) )

end % mustBeDirection

function mustBeLegendLocation( location )
%MUSTBELEGENDLOCATION Validate that the given location is a member of the
%available legend locations.

leg = matlab.graphics.illustration.Legend();
legendCleanup = onCleanup( @() delete( leg ) );
validLocations = set( leg, "Location" );
mustBeMember( location, validLocations )

end % mustBeLegendLocation

function mustBeColor( c, opts )
%MUSTBECOLOR Validate the given input, c, is a valid color or a member of
%the finite set of string options opts.

c = convertCharsToStrings( c );
if ~isstring( c ) || ~ismember( c, opts )
    validatecolor( c );
end % if

end % mustBeColor
##### SOURCE END #####
-->
</body>
</html>
