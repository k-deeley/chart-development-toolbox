<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>CylinderChart</title>
<meta name="generator" content="MATLAB 25.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-01-11">
<meta name="DC.source" content="CylinderChart.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<pre class="codeinput">
<span class="keyword">classdef</span> CylinderChart &lt; Chart
    <span class="comment">%CYLINDERCHART Chart representing a stacked cylinder graph.</span>

    <span class="comment">% Copyright 2018-2025 The MathWorks, Inc.</span>

    <span class="keyword">properties</span> ( Dependent )
        <span class="comment">% Chart data.</span>
        Data<span class="typesection">(:, :) double {mustBeNonnegative, mustBeFinite}</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Dependent )</span>

    <span class="keyword">properties</span>
        <span class="comment">% Axes view (azimuth, elevation).</span>
        View<span class="typesection">(1, 2) double {mustBeReal, mustBeFinite}</span> = [-16, 12]
    <span class="keyword">end</span> <span class="comment">% properties</span>

    <span class="keyword">properties</span> ( Dependent )
        <span class="comment">% Three-column numeric matrix of cylinder face colors.</span>
        FaceColors
    <span class="keyword">end</span> <span class="comment">% properties ( Dependent )</span>

    <span class="keyword">properties</span> ( Dependent, SetAccess = private )
        <span class="comment">% Number of cylindrical stacks.</span>
        NumStacks<span class="typesection">(1, 1) double {mustBeInteger, mustBeNonnegative}</span>
        <span class="comment">% Number of layers within each cylindrical stack.</span>
        NumLayers<span class="typesection">(1, 1) double {mustBeInteger, mustBeNonnegative}</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Dependent, SetAccess = private )</span>

    <span class="keyword">properties</span> ( Access = private )
        <span class="comment">% Internal storage for the Data property.</span>
        Data_<span class="typesection">(:, :) double {mustBeNonnegative, mustBeFinite}</span> = <span class="keyword">...</span>
            double.empty( 0, 0 )
        <span class="comment">% Internal storage for the FaceColors property.</span>
        FaceColors_<span class="typesection">(:, 3) double {mustBeInRange( FaceColors_, 0, 1 )}</span> = <span class="keyword">...</span>
            cool()
        <span class="comment">% Logical scalar specifying whether a computation is required.</span>
        ComputationRequired<span class="typesection">(1, 1) logical </span>= false
    <span class="keyword">end</span> <span class="comment">% properties ( Access = private )</span>

    <span class="keyword">properties</span> ( Access = private, Transient, NonCopyable )
        <span class="comment">% Chart axes.</span>
        Axes<span class="typesection">(:, 1) matlab.graphics.axis.Axes {mustBeScalarOrEmpty}</span>
        <span class="comment">% Surface graphics objects used for the cylinders.</span>
        CylinderSurfaces<span class="typesection">(:, :) matlab.graphics.primitive.Surface</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Access = private, Transient, NonCopyable )</span>

    <span class="keyword">properties</span> ( Constant, Hidden )
        <span class="comment">% Product dependencies.</span>
        Dependencies<span class="typesection">(1, :) string </span>= <span class="string">"MATLAB"</span>
        <span class="comment">% Description.</span>
        ShortDescription<span class="typesection">(1, 1) string </span>= <span class="string">"Plot data using stacked cylinders"</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Constant, Hidden )</span>

    <span class="keyword">methods</span>

        <span class="keyword">function</span> value = get.Data( obj )

            value = obj.Data_;

        <span class="keyword">end</span> <span class="comment">% get.Data</span>

        <span class="keyword">function</span> set.Data( obj, value )

            <span class="comment">% Mark the chart for an update.</span>
            obj.ComputationRequired = true;

            <span class="comment">% Update the internal stored property.</span>
            obj.Data_ = value;

        <span class="keyword">end</span> <span class="comment">% set.Data</span>

        <span class="keyword">function</span> value = get.FaceColors( obj )

            value = obj.FaceColors_;

        <span class="keyword">end</span> <span class="comment">% get.FaceColors</span>

        <span class="keyword">function</span> set.FaceColors( obj, value )

            <span class="comment">% Check the user-supplied list of colors.</span>
            value = validatecolor( value, <span class="string">"multiple"</span> );
            assert( isequal( size( value ), [obj.NumLayers, 3] ), <span class="keyword">...</span>
                <span class="string">"Cylinder:InvalidFaceColors"</span>, <span class="keyword">...</span>
                <span class="string">"The FaceColors property must be a matrix with "</span> + <span class="keyword">...</span>
                <span class="string">"the number of rows equal to the number of data columns."</span> )

            <span class="comment">% Update the face colors of each layer in each stack.</span>
            drawnow()
            <span class="keyword">for</span> k = 1 : obj.NumLayers
                set( obj.CylinderSurfaces(:, k), <span class="string">"FaceColor"</span>, value(k, :) )
            <span class="keyword">end</span> <span class="comment">% for</span>

            <span class="comment">% Update the internal stored property.</span>
            obj.FaceColors_ = value;

        <span class="keyword">end</span> <span class="comment">% set.FaceColors</span>

        <span class="keyword">function</span> value = get.NumStacks( obj )

            value = height( obj.Data_ );

        <span class="keyword">end</span> <span class="comment">% get.NumStacks</span>

        <span class="keyword">function</span> value = get.NumLayers( obj )

            value = width( obj.Data_ );

        <span class="keyword">end</span> <span class="comment">% get.NumLayers</span>

    <span class="keyword">end</span> <span class="comment">% methods</span>

    <span class="keyword">methods</span>

        <span class="keyword">function</span> obj = CylinderChart( namedArgs )
            <span class="comment">%CYLINDERCHART Construct a CylinderChart, given optional</span>
            <span class="comment">%name-value arguments.</span>

            <span class="keyword">arguments</span> ( Input )
                namedArgs.?CylinderChart
            <span class="keyword">end</span> <span class="comment">% arguments ( Input )</span>

            <span class="comment">% Set any user-defined properties.</span>
            set( obj, namedArgs )

        <span class="keyword">end</span> <span class="comment">% constructor</span>

        <span class="keyword">function</span> varargout = xlabel( obj, varargin )

            [varargout{1:nargout}] = xlabel( obj.Axes, varargin{:} );

        <span class="keyword">end</span> <span class="comment">% xlabel</span>

        <span class="keyword">function</span> varargout = zlabel( obj, varargin )

            [varargout{1:nargout}] = zlabel( obj.Axes, varargin{:} );

        <span class="keyword">end</span> <span class="comment">% zlabel</span>

        <span class="keyword">function</span> varargout = title( obj, varargin )

            [varargout{1:nargout}] = title( obj.Axes, varargin{:} );

        <span class="keyword">end</span> <span class="comment">% title</span>

        <span class="keyword">function</span> varargout = legend( obj, varargin )

            <span class="keyword">if</span> ~isempty( obj.CylinderSurfaces )
                [varargout{1:nargout}] = legend( <span class="keyword">...</span>
                    obj.CylinderSurfaces(1, :), varargin{:} );
            <span class="keyword">end</span> <span class="comment">% if</span>

        <span class="keyword">end</span> <span class="comment">% legend</span>

        <span class="keyword">function</span> varargout = xticklabels( obj, varargin )

            [varargout{1:nargout}] = xticklabels( obj.Axes, varargin{:} );

        <span class="keyword">end</span> <span class="comment">% xticklabels</span>

        <span class="keyword">function</span> varargout = xtickangle( obj, varargin )

            [varargout{1:nargout}] = xtickangle( obj.Axes, varargin{:} );

        <span class="keyword">end</span> <span class="comment">% xtickangle</span>

        <span class="keyword">function</span> varargout = axis( obj, varargin )

            [varargout{1:nargout}] = axis( obj.Axes, varargin{:} );

        <span class="keyword">end</span> <span class="comment">% axis</span>

    <span class="keyword">end</span> <span class="comment">% methods</span>

    <span class="keyword">methods</span> ( Access = protected )

        <span class="keyword">function</span> setup( obj )
            <span class="comment">%SETUP Initialize the chart graphics.</span>

            <span class="comment">% Create the axes.</span>
            obj.Axes = axes( <span class="string">"Parent"</span>, obj.getLayout(), <span class="keyword">...</span>
                <span class="string">"XGrid"</span>, <span class="string">"on"</span>, <span class="keyword">...</span>
                <span class="string">"YGrid"</span>, <span class="string">"on"</span>, <span class="keyword">...</span>
                <span class="string">"ZGrid"</span>, <span class="string">"on"</span>, <span class="keyword">...</span>
                <span class="string">"YLim"</span>, [-2, 4], <span class="keyword">...</span>
                <span class="string">"YTick"</span>, [] );

            <span class="comment">% Set the required axes properties.</span>
            obj.Axes.DataAspectRatio(1:2) = [1, 1];
            obj.Axes.ZAxis.TickDirection = <span class="string">"in"</span>;
            obj.Axes.ZAxis.TickLength(2) = <span class="keyword">...</span>
                3 * obj.Axes.ZAxis.TickLength(2);

        <span class="keyword">end</span> <span class="comment">% setup</span>

        <span class="keyword">function</span> update( obj )
            <span class="comment">%UPDATE Refresh the chart graphics.</span>

            <span class="keyword">if</span> obj.ComputationRequired

                <span class="comment">% First, record the previous number of layers (this is used</span>
                <span class="comment">% to preserve the existing face colors if possible).</span>
                prevNumLayers = width( obj.CylinderSurfaces );
                <span class="comment">% Similarly, record the previous number of stacks (this is</span>
                <span class="comment">% used to preserve the existing tick labels if possible).</span>
                prevNumStacks = height( obj.CylinderSurfaces );

                <span class="comment">% Update the number of surface objects in accordance with</span>
                <span class="comment">% the data. Start by deleting the existing cylinders if</span>
                <span class="comment">% they exist.</span>
                <span class="keyword">if</span> ~isempty( obj.CylinderSurfaces )
                    delete( obj.CylinderSurfaces )
                <span class="keyword">end</span> <span class="comment">% if</span>

                <span class="comment">% Preallocate for the new cylinders.</span>
                s = matlab.graphics.primitive.Surface();
                obj.CylinderSurfaces = <span class="keyword">...</span>
                    repmat( s, obj.NumStacks, obj.NumLayers );

                <span class="comment">% Determine the face colors: use the previous colors if</span>
                <span class="comment">% possible; otherwise, revert to a default set of colors.</span>
                <span class="keyword">if</span> obj.NumLayers &lt;= prevNumLayers
                    obj.FaceColors_ = obj.FaceColors_(1:obj.NumLayers, :);
                <span class="keyword">else</span>
                    obj.FaceColors_ = cool( obj.NumLayers );
                <span class="keyword">end</span> <span class="comment">% if</span>

                <span class="comment">% Create the new cylinders.</span>
                <span class="keyword">for</span> k1 = 1 : obj.NumStacks
                    <span class="keyword">for</span> k2 = 1 : obj.NumLayers
                        obj.CylinderSurfaces(k1, k2) = <span class="keyword">...</span>
                            surface( obj.Axes, [], [], [], <span class="keyword">...</span>
                            <span class="string">"FaceColor"</span>, obj.FaceColors_(k2, :), <span class="keyword">...</span>
                            <span class="string">"EdgeAlpha"</span>, 0 );
                    <span class="keyword">end</span> <span class="comment">% for k2</span>
                <span class="keyword">end</span> <span class="comment">% for k1</span>

                <span class="comment">% Compute the cylindrical coordinates.</span>
                <span class="comment">% Define the number of points used for the cylinder</span>
                <span class="comment">% circumferences and the radius of the cylinders.</span>
                n = 1000;
                r = 2 * [1; 1];
                <span class="comment">% Cylinder heights above the (x, y) plane.</span>
                heights = [zeros( obj.NumStacks, 1 ), <span class="keyword">...</span>
                    cumsum( obj.Data_, 2 )];
                <span class="comment">% Angles from 0 to 2*pi.</span>
                theta = 2 * ( 0 : n ) / n;
                <span class="comment">% Compute sin(theta), ensuring the final value is exactly</span>
                <span class="comment">% zero.</span>
                sintheta = sinpi( theta );
                rsintheta = r * sintheta;
                rcostheta = r * cospi( theta );
                <span class="comment">% Compute the coordinates of the cylinders, and update the</span>
                <span class="comment">% surface objects and rings.</span>
                y = 1 + rsintheta;
                <span class="keyword">for</span> k1 = 1:obj.NumStacks
                    x = 5*k1 + rcostheta;
                    <span class="keyword">for</span> k2 = 1:obj.NumLayers
                        z = heights(k1, k2:(k2+1)).' * ones( 1, n + 1 );
                        set( obj.CylinderSurfaces(k1, k2), <span class="keyword">...</span>
                            <span class="string">"XData"</span>, x, <span class="string">"YData"</span>, y, <span class="string">"ZData"</span>, z )
                    <span class="keyword">end</span> <span class="comment">% for k2</span>
                <span class="keyword">end</span> <span class="comment">% for k1</span>

                <span class="comment">% Update the axes properties.</span>
                set( obj.Axes, <span class="string">"XLim"</span>, [1, 5 * obj.NumStacks + 4], <span class="keyword">...</span>
                    <span class="string">"XTick"</span>, 5 * (1 : obj.NumStacks) )
                <span class="comment">% Reuse the previous tick labels, if possible.</span>
                <span class="keyword">if</span> obj.NumStacks &lt;= prevNumStacks
                    obj.Axes.XTickLabel = <span class="keyword">...</span>
                        obj.Axes.XTickLabel(1:obj.NumStacks);
                <span class="keyword">else</span>
                    obj.Axes.XTickLabel = 1:obj.NumStacks;
                <span class="keyword">end</span> <span class="comment">% if</span>

                <span class="comment">% Mark the chart clean.</span>
                obj.ComputationRequired = false;

            <span class="keyword">end</span> <span class="comment">% if</span>

            <span class="comment">% Refresh the chart's decorative properties.</span>
            obj.Axes.View = obj.View;

        <span class="keyword">end</span> <span class="comment">% update</span>

    <span class="keyword">end</span> <span class="comment">% methods ( Access = protected )</span>

<span class="keyword">end</span> <span class="comment">% classdef</span>
</pre>
</div>
<!--
##### SOURCE BEGIN #####
classdef CylinderChart < Chart
    %CYLINDERCHART Chart representing a stacked cylinder graph.

    % Copyright 2018-2025 The MathWorks, Inc.

    properties ( Dependent )
        % Chart data.
        Data(:, :) double {mustBeNonnegative, mustBeFinite}
    end % properties ( Dependent )

    properties
        % Axes view (azimuth, elevation).
        View(1, 2) double {mustBeReal, mustBeFinite} = [-16, 12]
    end % properties

    properties ( Dependent )
        % Three-column numeric matrix of cylinder face colors.
        FaceColors
    end % properties ( Dependent )

    properties ( Dependent, SetAccess = private )
        % Number of cylindrical stacks.
        NumStacks(1, 1) double {mustBeInteger, mustBeNonnegative}
        % Number of layers within each cylindrical stack.
        NumLayers(1, 1) double {mustBeInteger, mustBeNonnegative}
    end % properties ( Dependent, SetAccess = private )

    properties ( Access = private )
        % Internal storage for the Data property.
        Data_(:, :) double {mustBeNonnegative, mustBeFinite} = ...
            double.empty( 0, 0 )
        % Internal storage for the FaceColors property.
        FaceColors_(:, 3) double {mustBeInRange( FaceColors_, 0, 1 )} = ...
            cool()
        % Logical scalar specifying whether a computation is required.
        ComputationRequired(1, 1) logical = false
    end % properties ( Access = private )

    properties ( Access = private, Transient, NonCopyable )
        % Chart axes.
        Axes(:, 1) matlab.graphics.axis.Axes {mustBeScalarOrEmpty}
        % Surface graphics objects used for the cylinders.
        CylinderSurfaces(:, :) matlab.graphics.primitive.Surface
    end % properties ( Access = private, Transient, NonCopyable )

    properties ( Constant, Hidden )
        % Product dependencies.
        Dependencies(1, :) string = "MATLAB"
        % Description.
        ShortDescription(1, 1) string = "Plot data using stacked cylinders"
    end % properties ( Constant, Hidden )

    methods

        function value = get.Data( obj )

            value = obj.Data_;

        end % get.Data

        function set.Data( obj, value )

            % Mark the chart for an update.
            obj.ComputationRequired = true;

            % Update the internal stored property.
            obj.Data_ = value;

        end % set.Data

        function value = get.FaceColors( obj )

            value = obj.FaceColors_;

        end % get.FaceColors

        function set.FaceColors( obj, value )

            % Check the user-supplied list of colors.
            value = validatecolor( value, "multiple" );
            assert( isequal( size( value ), [obj.NumLayers, 3] ), ...
                "Cylinder:InvalidFaceColors", ...
                "The FaceColors property must be a matrix with " + ...
                "the number of rows equal to the number of data columns." )

            % Update the face colors of each layer in each stack.
            drawnow()
            for k = 1 : obj.NumLayers
                set( obj.CylinderSurfaces(:, k), "FaceColor", value(k, :) )
            end % for

            % Update the internal stored property.
            obj.FaceColors_ = value;

        end % set.FaceColors

        function value = get.NumStacks( obj )

            value = height( obj.Data_ );

        end % get.NumStacks

        function value = get.NumLayers( obj )

            value = width( obj.Data_ );

        end % get.NumLayers

    end % methods

    methods

        function obj = CylinderChart( namedArgs )
            %CYLINDERCHART Construct a CylinderChart, given optional
            %name-value arguments.

            arguments ( Input )
                namedArgs.?CylinderChart
            end % arguments ( Input )            

            % Set any user-defined properties.
            set( obj, namedArgs )

        end % constructor

        function varargout = xlabel( obj, varargin )

            [varargout{1:nargout}] = xlabel( obj.Axes, varargin{:} );

        end % xlabel

        function varargout = zlabel( obj, varargin )

            [varargout{1:nargout}] = zlabel( obj.Axes, varargin{:} );

        end % zlabel

        function varargout = title( obj, varargin )

            [varargout{1:nargout}] = title( obj.Axes, varargin{:} );

        end % title

        function varargout = legend( obj, varargin )

            if ~isempty( obj.CylinderSurfaces )
                [varargout{1:nargout}] = legend( ...
                    obj.CylinderSurfaces(1, :), varargin{:} );
            end % if

        end % legend

        function varargout = xticklabels( obj, varargin )

            [varargout{1:nargout}] = xticklabels( obj.Axes, varargin{:} );

        end % xticklabels

        function varargout = xtickangle( obj, varargin )

            [varargout{1:nargout}] = xtickangle( obj.Axes, varargin{:} );

        end % xtickangle

        function varargout = axis( obj, varargin )

            [varargout{1:nargout}] = axis( obj.Axes, varargin{:} );

        end % axis

    end % methods

    methods ( Access = protected )

        function setup( obj )
            %SETUP Initialize the chart graphics.

            % Create the axes.
            obj.Axes = axes( "Parent", obj.getLayout(), ...
                "XGrid", "on", ...
                "YGrid", "on", ...
                "ZGrid", "on", ...
                "YLim", [-2, 4], ...
                "YTick", [] );

            % Set the required axes properties.
            obj.Axes.DataAspectRatio(1:2) = [1, 1];
            obj.Axes.ZAxis.TickDirection = "in";
            obj.Axes.ZAxis.TickLength(2) = ...
                3 * obj.Axes.ZAxis.TickLength(2);

        end % setup

        function update( obj )
            %UPDATE Refresh the chart graphics.

            if obj.ComputationRequired

                % First, record the previous number of layers (this is used
                % to preserve the existing face colors if possible).
                prevNumLayers = width( obj.CylinderSurfaces );
                % Similarly, record the previous number of stacks (this is
                % used to preserve the existing tick labels if possible).
                prevNumStacks = height( obj.CylinderSurfaces );

                % Update the number of surface objects in accordance with
                % the data. Start by deleting the existing cylinders if
                % they exist.
                if ~isempty( obj.CylinderSurfaces )
                    delete( obj.CylinderSurfaces )
                end % if

                % Preallocate for the new cylinders.
                s = matlab.graphics.primitive.Surface();
                obj.CylinderSurfaces = ...
                    repmat( s, obj.NumStacks, obj.NumLayers );

                % Determine the face colors: use the previous colors if
                % possible; otherwise, revert to a default set of colors.
                if obj.NumLayers <= prevNumLayers
                    obj.FaceColors_ = obj.FaceColors_(1:obj.NumLayers, :);
                else
                    obj.FaceColors_ = cool( obj.NumLayers );
                end % if

                % Create the new cylinders.
                for k1 = 1 : obj.NumStacks
                    for k2 = 1 : obj.NumLayers
                        obj.CylinderSurfaces(k1, k2) = ...
                            surface( obj.Axes, [], [], [], ...
                            "FaceColor", obj.FaceColors_(k2, :), ...
                            "EdgeAlpha", 0 );
                    end % for k2
                end % for k1

                % Compute the cylindrical coordinates.
                % Define the number of points used for the cylinder
                % circumferences and the radius of the cylinders.
                n = 1000;
                r = 2 * [1; 1];
                % Cylinder heights above the (x, y) plane.
                heights = [zeros( obj.NumStacks, 1 ), ...
                    cumsum( obj.Data_, 2 )];
                % Angles from 0 to 2*pi.
                theta = 2 * ( 0 : n ) / n;
                % Compute sin(theta), ensuring the final value is exactly
                % zero.
                sintheta = sinpi( theta );
                rsintheta = r * sintheta;
                rcostheta = r * cospi( theta );
                % Compute the coordinates of the cylinders, and update the
                % surface objects and rings.
                y = 1 + rsintheta;
                for k1 = 1:obj.NumStacks
                    x = 5*k1 + rcostheta;
                    for k2 = 1:obj.NumLayers
                        z = heights(k1, k2:(k2+1)).' * ones( 1, n + 1 );
                        set( obj.CylinderSurfaces(k1, k2), ...
                            "XData", x, "YData", y, "ZData", z )
                    end % for k2
                end % for k1

                % Update the axes properties.
                set( obj.Axes, "XLim", [1, 5 * obj.NumStacks + 4], ...
                    "XTick", 5 * (1 : obj.NumStacks) )
                % Reuse the previous tick labels, if possible.
                if obj.NumStacks <= prevNumStacks
                    obj.Axes.XTickLabel = ...
                        obj.Axes.XTickLabel(1:obj.NumStacks);
                else
                    obj.Axes.XTickLabel = 1:obj.NumStacks;
                end % if

                % Mark the chart clean.
                obj.ComputationRequired = false;

            end % if

            % Refresh the chart's decorative properties.
            obj.Axes.View = obj.View;

        end % update

    end % methods ( Access = protected )

end % classdef
##### SOURCE END #####
-->
</body>
</html>
