<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
<!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      -->
<title>SankeyChart</title>
<meta name="generator" content="MATLAB 25.1">
<link rel="schema.DC" href="http://purl.org/dc/elements/1.1/">
<meta name="DC.date" content="2025-01-11">
<meta name="DC.source" content="SankeyChart.m">
<style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; }

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
tt { font-size: 1.2em; }
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:100%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }
span.typesection { color:#A0522D }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style>
</head>
<body>
<div class="content">
<pre class="codeinput">
<span class="keyword">classdef</span> SankeyChart &lt; Chart
    <span class="comment">%SANKEYCHART Illustrate the flow between different states.</span>

    <span class="comment">% Copyright 2018-2025 The MathWorks, Inc.</span>

    <span class="keyword">properties</span> ( Dependent )
        <span class="comment">% Directed graph representing the Sankey diagram.</span>
        GraphData<span class="typesection">(1, 1) digraph</span>
        <span class="comment">% Node label alignment.</span>
        LabelAlignment<span class="typesection">(1, 1) string {mustBeMember( LabelAlignment, </span><span class="keyword">...</span>
            <span class="typesection">["left", "right", "top", "bottom", "center"] )}</span>
        <span class="comment">% Flag to display totals.</span>
        LabelIncludeTotal<span class="typesection">(1, 1) matlab.lang.OnOffSwitchState</span>
        <span class="comment">% Link color.</span>
        LinkColor
        <span class="comment">% Curve type.</span>
        LinkType<span class="typesection">(1, 1) string {mustBeMember( LinkType, </span><span class="keyword">...</span>
            <span class="typesection">["tanh", "cos", "vtanh", "vcos", "line"] )}</span>
        <span class="comment">% Node color.</span>
        NodeColor
        <span class="comment">% Vertical space between nodes.</span>
        NodePadRatio<span class="typesection">(1, 1) double {mustBeNonnegative, mustBeFinite}</span>
        <span class="comment">% Node width.</span>
        NodeWidth<span class="typesection">(1, 1) double {mustBeNonnegative, mustBeFinite}</span>
        <span class="comment">% Node x-coordinates.</span>
        XNodeData<span class="typesection">(:, 1) double {mustBeReal, mustBeFinite}</span>
        <span class="comment">% Node y-coordinates.</span>
        YNodeData<span class="typesection">(:, 1) double {mustBeReal, mustBeFinite}</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Dependent )</span>

    <span class="keyword">properties</span>
        <span class="comment">% Link transparency.</span>
        LinkAlpha<span class="typesection">(1, 1) double {mustBeInRange( LinkAlpha, 0, 1 )}</span> = 0.5
        <span class="comment">% Link edge color.</span>
        LinkEdgeColor <span class="typesection">{validatecolor}</span> = <span class="string">"black"</span>
        <span class="comment">% Link edge style.</span>
        LinkEdgeStyle<span class="typesection">(1, 1) string {mustBeLineStyle}</span> = <span class="string">"none"</span>
        <span class="comment">% Link edge width.</span>
        LinkEdgeWidth<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 0.5
        <span class="comment">% Font size for link annotations.</span>
        LinkFontSize<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 10
        <span class="comment">% Node transparency.</span>
        NodeAlpha<span class="typesection">(1, 1) double {mustBeInRange( NodeAlpha, 0, 1 )}</span> = 1
        <span class="comment">% Node edge color.</span>
        NodeEdgeColor <span class="typesection">{validatecolor}</span> = <span class="string">"black"</span>
        <span class="comment">% Node edge line style.</span>
        NodeEdgeStyle<span class="typesection">(1, 1) string {mustBeLineStyle}</span> = <span class="string">"-"</span>
        <span class="comment">% Node edge width.</span>
        NodeEdgeWidth<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 0.5
        <span class="comment">% Node label font size.</span>
        NodeFontSize<span class="typesection">(1, 1) double {mustBePositive, mustBeFinite}</span> = 10
        <span class="comment">% Node label visibility.</span>
        NodeLabelsVisible<span class="typesection">(1, 1) matlab.lang.OnOffSwitchState </span>= <span class="string">"on"</span>
    <span class="keyword">end</span> <span class="comment">% properties</span>

    <span class="keyword">properties</span> ( Access = private, Transient, NonCopyable )
        <span class="comment">% The chart's axes.</span>
        Axes<span class="typesection">(:, 1) matlab.graphics.axis.Axes {mustBeScalarOrEmpty}</span>
        <span class="comment">% Text objects for the link labels.</span>
        LinkLabels<span class="typesection">(:, 1) matlab.graphics.primitive.Text</span>
        <span class="comment">% Patch objects for the links.</span>
        LinkPatches<span class="typesection">(:, 1) matlab.graphics.primitive.Patch</span>
        <span class="comment">% Text objects for the node labels.</span>
        NodeLabels<span class="typesection">(:, 1) matlab.graphics.primitive.Text</span>
        <span class="comment">% Patch objects for the nodes.</span>
        NodePatches<span class="typesection">(:, 1) matlab.graphics.primitive.Patch</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Access = private, Transient, NonCopyable )</span>

    <span class="keyword">properties</span> ( Access = private )
        <span class="comment">% Logical scalar specifying whether a computation is required.</span>
        ComputationRequired<span class="typesection">(1, 1) logical </span>= false
        <span class="comment">% Backing for LabelAlignment.</span>
        LabelAlignment_<span class="typesection">(1, 1) string {mustBeMember( LabelAlignment_, </span><span class="keyword">...</span>
            <span class="typesection">["left", "right", "top", "bottom", "center"] )}</span> = <span class="string">"right"</span>
        <span class="comment">% Backing for LabelIncludeTotal.</span>
        LabelIncludeTotal_<span class="typesection">(1, 1) matlab.lang.OnOffSwitchState </span>= <span class="string">"off"</span>
        <span class="comment">% Backing for LinkColor.</span>
        LinkColor_ = <span class="string">"source"</span>
        <span class="comment">% Backing for LinkType.</span>
        LinkType_<span class="typesection">(1, 1) string {mustBeMember( LinkType_, </span><span class="keyword">...</span>
            <span class="typesection">["tanh", "cos", "vtanh", "vcos", "line"] )}</span> = <span class="string">"cos"</span>
        <span class="comment">% Link cross type.</span>
        LinkCrossType<span class="typesection">(1, 1) string {mustBeMember( LinkCrossType, </span><span class="keyword">...</span>
            <span class="typesection">["vertical", "normal"] )}</span> = <span class="string">"normal"</span>
        <span class="comment">% Backing for GraphData.</span>
        GraphData_<span class="typesection">(1, 1) digraph </span>= digraph()
        <span class="comment">% Backing for NodeColor.</span>
        NodeColor_ = zeros( 0, 3 )
        <span class="comment">% Node height.</span>
        NodeHeight<span class="typesection">(:, 1) double {mustBePositive, mustBeFinite}</span> = <span class="keyword">...</span>
            double.empty( 0, 1 )
        <span class="comment">% Backing for NodePadRatio.</span>
        NodePadRatio_<span class="typesection">(1, 1) double {mustBeNonnegative, mustBeFinite}</span> = 0.05
        <span class="comment">% Logical array indicating whether nodes are selected.</span>
        NodeSelected<span class="typesection">(:, 1) logical </span>= false( 0, 1 )
        <span class="comment">% Backing for NodeWidth.</span>
        NodeWidth_<span class="typesection">(1, 1) double {mustBeNonnegative, mustBeFinite}</span> = 0.1
        <span class="comment">% Backing for XNodeData.</span>
        XNodeData_<span class="typesection">(:, 1) double {mustBeReal, mustBeFinite}</span> = zeros( 0, 1 )
        <span class="comment">% Backing for YNodeData.</span>
        YNodeData_<span class="typesection">(:, 1) double {mustBeReal, mustBeFinite}</span> = zeros( 0, 1 )
        <span class="comment">% Y link data.</span>
        YLinkData<span class="typesection">(:, :) double {mustBeReal, mustBeFinite}</span> = zeros( 0, 1 )
    <span class="keyword">end</span> <span class="comment">% properties ( Access = private )</span>

    <span class="keyword">properties</span> ( Constant, Hidden )
        <span class="comment">% Product dependencies.</span>
        Dependencies<span class="typesection">(1, :) string </span>= <span class="string">"MATLAB"</span>
        <span class="comment">% Description.</span>
        ShortDescription<span class="typesection">(1, 1) string </span>= <span class="string">"Illustrate the flow between"</span> + <span class="keyword">...</span>
            <span class="string">" different states"</span>
    <span class="keyword">end</span> <span class="comment">% properties ( Constant, Hidden )</span>

    <span class="keyword">methods</span>

        <span class="keyword">function</span> obj = SankeyChart( namedArgs )
            <span class="comment">%SANKEYCHART Construct a SankeyChart, given optional name-value</span>
            <span class="comment">%arguments.</span>

            <span class="keyword">arguments</span> ( Input )
                namedArgs.?SankeyChart
            <span class="keyword">end</span> <span class="comment">% arguments ( Input )</span>

            <span class="comment">% Set any user-defined properties.</span>
            set( obj, namedArgs )

        <span class="keyword">end</span> <span class="comment">% constructor</span>

        <span class="keyword">function</span> set.LabelAlignment( obj, value )

            obj.LabelAlignment_ = value;
            updateNodeLabels( obj )

        <span class="keyword">end</span> <span class="comment">% set.LabelAlignment</span>

        <span class="keyword">function</span> value = get.LabelAlignment( obj )

            value = obj.LabelAlignment_;

        <span class="keyword">end</span> <span class="comment">% get.LabelAlignment</span>

        <span class="keyword">function</span> set.LabelIncludeTotal( obj, value )

            obj.LabelIncludeTotal_ = value;
            updateNodeLabels( obj )

        <span class="keyword">end</span> <span class="comment">% set.LabelIncludeTotal</span>

        <span class="keyword">function</span> value = get.LabelIncludeTotal( obj )

            value = obj.LabelIncludeTotal_;

        <span class="keyword">end</span> <span class="comment">% get.LabelIncludeTotal</span>

        <span class="keyword">function</span> set.LinkColor( obj, value )

            <span class="comment">% Validate.</span>
            value = convertCharsToStrings( value );
            <span class="keyword">if</span> ~isstring( value ) || ~ismember( value, <span class="keyword">...</span>
                    [<span class="string">"source"</span>, <span class="string">"target"</span>, <span class="string">"gradient"</span>] )
                value = validatecolor( value );
            <span class="keyword">end</span> <span class="comment">% if</span>

            <span class="comment">% Update.</span>
            obj.ComputationRequired = true;
            obj.LinkColor_ = value;

        <span class="keyword">end</span> <span class="comment">% set.LinkColor</span>

        <span class="keyword">function</span> value = get.LinkColor( obj )

            value = obj.LinkColor_;

        <span class="keyword">end</span> <span class="comment">% get.LinkColor</span>

        <span class="keyword">function</span> set.LinkType( obj, value )

            obj.ComputationRequired = true;

            pat = <span class="string">"v"</span>;
            <span class="keyword">if</span> startsWith( value, pat )
                obj.LinkType_ = extractBetween( value, pat, <span class="keyword">...</span>
                    textBoundary( <span class="string">"end"</span> ) );
                obj.LinkCrossType = <span class="string">"vertical"</span>;
            <span class="keyword">else</span>
                obj.LinkType_ = value;
                obj.LinkCrossType = <span class="string">"normal"</span>;
            <span class="keyword">end</span> <span class="comment">% if</span>

        <span class="keyword">end</span> <span class="comment">% set.LinkType</span>

        <span class="keyword">function</span> value = get.LinkType( obj )

            <span class="keyword">if</span> obj.LinkCrossType == <span class="string">"vertical"</span>
                value = <span class="string">"v"</span> + obj.LinkType_;
            <span class="keyword">else</span>
                value = obj.LinkType_;
            <span class="keyword">end</span> <span class="comment">% if</span>

        <span class="keyword">end</span> <span class="comment">% get.LinkType</span>

        <span class="keyword">function</span> set.GraphData( obj, value )

            <span class="comment">% Check.</span>
            <span class="keyword">if</span> ismultigraph( value ) || <span class="keyword">...</span>
                    any( diag( adjacency( obj.GraphData_ ) ) )
                error( <span class="string">"SankeyChart:NotSimpleGraph"</span>, <span class="keyword">...</span>
                    <span class="string">"The given graph is not simple. Use simplify to "</span> + <span class="keyword">...</span>
                    <span class="string">"remove multiple edges and self-loops."</span> )
            <span class="keyword">end</span> <span class="comment">% if</span>

            <span class="comment">% Update internal properties.</span>
            obj.ComputationRequired = true;
            obj.GraphData_ = value;

            <span class="comment">% Making sure weights are specified.</span>
            <span class="keyword">if</span> ~ismember( <span class="string">"Weight"</span>, <span class="keyword">...</span>
                    obj.GraphData_.Edges.Properties.VariableNames )
                obj.GraphData_.Edges.Weight = <span class="keyword">...</span>
                    ones( obj.GraphData_.numedges, 1 );
            <span class="keyword">end</span> <span class="comment">% if</span>

            <span class="comment">% Compute node flows.</span>
            A = adjacency( obj.GraphData_, <span class="string">"weighted"</span> );
            inflow  = sum( A, 1 )';
            outflow = sum( A, 2 );
            src = inflow == 0;
            snk = outflow == 0;

            <span class="comment">% Issue a warning for unbalanced graphs.</span>
            <span class="keyword">if</span> ~isequal( inflow(~src &amp; ~snk), outflow(~src &amp; ~snk) )
                warning( <span class="string">"SankeyChart:UnbalancedGraph"</span>, <span class="keyword">...</span>
                    <span class="string">"The given graph is unbalanced."</span> )
            <span class="keyword">end</span> <span class="comment">% if</span>

            <span class="comment">% Compute node and link coordinates.</span>
            obj.NodeHeight = full( max( inflow, outflow ) );
            nodeCoordinates( obj )

            <span class="comment">% Set node colors.</span>
            obj.NodeColor_ = lines( obj.GraphData_.numnodes );

            <span class="comment">% Update the selection.</span>
            obj.NodeSelected = false( obj.GraphData_.numnodes, 1 );

        <span class="keyword">end</span> <span class="comment">% set.GraphData</span>

        <span class="keyword">function</span> value = get.GraphData( obj )

            value = obj.GraphData_;

        <span class="keyword">end</span> <span class="comment">% get.GraphData</span>

        <span class="keyword">function</span> set.NodeColor( obj, value )

            <span class="comment">% Check.</span>
            nodeColor = validatecolor( value, <span class="string">"multiple"</span> );
            validateattributes( nodeColor, <span class="string">"double"</span>, <span class="keyword">...</span>
                {<span class="string">"size"</span>, size( obj.NodeColor_ )} )

            <span class="comment">% Update.</span>
            obj.ComputationRequired = true;
            obj.NodeColor_ = nodeColor;

        <span class="keyword">end</span> <span class="comment">% set.NodeColor</span>

        <span class="keyword">function</span> value = get.NodeColor( obj )

            value = obj.NodeColor_;

        <span class="keyword">end</span> <span class="comment">% get.NodeColor</span>

        <span class="keyword">function</span> set.NodePadRatio( obj, value )

            obj.ComputationRequired = true;
            obj.NodePadRatio_ = value;
            nodeCoordinates( obj )

        <span class="keyword">end</span> <span class="comment">% set.NodePadRatio</span>

        <span class="keyword">function</span> value = get.NodePadRatio( obj )

            value = obj.NodePadRatio_;

        <span class="keyword">end</span> <span class="comment">% get.NodePadRatio</span>

        <span class="keyword">function</span> set.NodeWidth( obj, value )

            obj.ComputationRequired = true;
            obj.NodeWidth_ = value;

        <span class="keyword">end</span> <span class="comment">% set.NodeWidth</span>

        <span class="keyword">function</span> value = get.NodeWidth( obj )

            value = obj.NodeWidth_;

        <span class="keyword">end</span> <span class="comment">% get.NodeWidth</span>

        <span class="keyword">function</span> set.XNodeData( obj, value )

            <span class="comment">% Check.</span>
            validateattributes( value, <span class="string">"double"</span>, <span class="keyword">...</span>
                {<span class="string">"size"</span>, size( obj.XNodeData_ )} )

            <span class="comment">% Update.</span>
            obj.ComputationRequired = true;
            obj.XNodeData_ = value;

        <span class="keyword">end</span> <span class="comment">% set.XNodeData</span>

        <span class="keyword">function</span> value = get.XNodeData( obj )

            value = obj.XNodeData_;

        <span class="keyword">end</span> <span class="comment">% get.XNodeData</span>

        <span class="keyword">function</span> set.YNodeData( obj, value )

            <span class="comment">% Check.</span>
            validateattributes( value, <span class="string">"double"</span>, <span class="keyword">...</span>
                {<span class="string">"size"</span>, size( obj.YNodeData_ )} )

            <span class="comment">% Update.</span>
            obj.ComputationRequired = true;
            obj.YNodeData_ = value;

            <span class="comment">% Recompute link coordinates.</span>
            updateLinkCoordinates( obj )

        <span class="keyword">end</span> <span class="comment">% set.YNodeData</span>

        <span class="keyword">function</span> value = get.YNodeData( obj )

            value = obj.YNodeData_;

        <span class="keyword">end</span> <span class="comment">% get.YNodeData</span>

    <span class="keyword">end</span> <span class="comment">% methods</span>

    <span class="keyword">methods</span>

        <span class="keyword">function</span> varargout = title( obj, varargin )

            [varargout{1:nargout}] = title( obj.Axes, varargin{:} );

        <span class="keyword">end</span> <span class="comment">% title</span>

    <span class="keyword">end</span> <span class="comment">% methods</span>

    <span class="keyword">methods</span> ( Access = private )

        <span class="keyword">function</span> updateLinkLabels( obj )
            <span class="comment">%UPDATELINKLABELS Helper method to update the link labels.</span>

            nLabels  = obj.GraphData_.numedges;
            nCurrent = numel( obj.LinkLabels );

            <span class="keyword">if</span> nLabels &lt; nCurrent

                delete( obj.LinkLabels(nLabels+1:nCurrent) )
                obj.LinkLabels(nLabels+1:nCurrent) = [];

            <span class="keyword">elseif</span> nLabels &gt; nCurrent

                <span class="keyword">for</span> eid = nCurrent+1:nLabels
                    obj.LinkLabels(eid) = text( <span class="string">"Parent"</span>, obj.Axes );
                <span class="keyword">end</span> <span class="comment">% for</span>

            <span class="keyword">end</span> <span class="comment">% if</span>

            <span class="keyword">for</span> eid = 1:nLabels

                linkSource = obj.GraphData_.Edges.EndNodes(eid, 1);
                linkTarget = obj.GraphData_.Edges.EndNodes(eid, 2);
                linkHeight = obj.GraphData_.Edges.Weight(eid);

                linkText = [sprintf( <span class="string">"Source: %s"</span>, <span class="keyword">...</span>
                    string( linkSource ) ), <span class="keyword">...</span>
                    sprintf( <span class="string">"Target: %s"</span>, string( linkTarget ) ), <span class="keyword">...</span>
                    sprintf( <span class="string">"Weight: %g"</span>, linkHeight )];

                textX = mean( obj.LinkPatches(eid).XData );
                textY = mean( obj.LinkPatches(eid).YData );

                set( obj.LinkLabels(eid), <span class="keyword">...</span>
                    <span class="string">"Position"</span>, [textX, textY], <span class="keyword">...</span>
                    <span class="string">"String"</span>, linkText, <span class="keyword">...</span>
                    <span class="string">"HorizontalAlignment"</span>, <span class="string">"center"</span>, <span class="keyword">...</span>
                    <span class="string">"VerticalAlignment"</span>, <span class="string">"middle"</span>, <span class="keyword">...</span>
                    <span class="string">"BackgroundColor"</span>, [1, 1, 1, 0.25], <span class="keyword">...</span>
                    <span class="string">"Margin"</span>, 1, <span class="keyword">...</span>
                    <span class="string">"Visible"</span>, <span class="string">"off"</span>, <span class="keyword">...</span>
                    <span class="string">"Clipping"</span>, <span class="string">"on"</span>, <span class="keyword">...</span>
                    <span class="string">"Tag"</span>, <span class="string">"LinkLabel"</span>, <span class="keyword">...</span>
                    <span class="string">"ButtonDownFcn"</span>, @(~, ~) onLinkClicked( obj, eid ) )

            <span class="keyword">end</span> <span class="comment">% for</span>

        <span class="keyword">end</span> <span class="comment">% updateLinkLabels</span>

        <span class="keyword">function</span> onLinkClicked( obj, id )
            <span class="comment">%ONLINKCLICKED Link left-click callback.</span>

            set( obj.LinkLabels(id), <span class="keyword">...</span>
                <span class="string">"Visible"</span>, ~obj.LinkLabels(id).Visible )

        <span class="keyword">end</span> <span class="comment">% onLinkClicked</span>

        <span class="keyword">function</span> updateLinkCoordinates( obj )
            <span class="comment">%UPDATELINKCOORDINATES Helper method to update the link</span>
            <span class="comment">%coordinates.</span>

            <span class="comment">% Compute link y-coordinates.</span>
            obj.YLinkData = zeros( obj.GraphData_.numedges, 2 );

            <span class="keyword">for</span> nid = 1:obj.GraphData_.numnodes

                <span class="comment">% Outbound links</span>
                [eid, tid] = outedges( obj.GraphData_, nid );
                targetY = obj.YNodeData_(tid) + obj.NodeHeight(tid)/2;
                [~, yOrdIdx] = sort( targetY );
                linkHeight = obj.GraphData_.Edges.Weight(eid(yOrdIdx));
                linkY = cumsum( linkHeight ) - linkHeight;
                obj.YLinkData(eid(yOrdIdx), 1) = <span class="keyword">...</span>
                    obj.YNodeData_(nid) + linkY;

                <span class="comment">% Inbound links</span>
                [eid, sid] = inedges( obj.GraphData_, nid );
                sourceY = obj.YNodeData_(sid) + obj.NodeHeight(sid)/2;
                [~, yOrdIdx] = sort( sourceY );
                linkHeight = obj.GraphData_.Edges.Weight(eid(yOrdIdx));
                linkY = cumsum( linkHeight ) - linkHeight;
                obj.YLinkData(eid(yOrdIdx), 2) = <span class="keyword">...</span>
                    obj.YNodeData_(nid) + linkY;

            <span class="keyword">end</span> <span class="comment">% for</span>

        <span class="keyword">end</span> <span class="comment">% updateLinkCoordinates</span>

        <span class="keyword">function</span> updateLinks( obj )
            <span class="comment">%UPDATELINKS Helper method to update links.</span>

            nLinks   = obj.GraphData_.numedges;
            nCurrent = numel( obj.LinkPatches );

            <span class="keyword">if</span> nLinks &lt; nCurrent

                delete( obj.LinkPatches(nLinks+1:nCurrent) )
                obj.LinkPatches(nLinks+1:nCurrent) = [];

            <span class="keyword">elseif</span> nLinks &gt; nCurrent

                <span class="keyword">for</span> eid = nCurrent+1:nLinks
                    obj.LinkPatches(eid) = patch( <span class="string">"Parent"</span>, obj.Axes );
                <span class="keyword">end</span> <span class="comment">% for</span>

            <span class="keyword">end</span> <span class="comment">% if</span>

            expand = @(x) reshape( x, [1, size( x )] );

            <span class="keyword">for</span> eid = 1:nLinks

                <span class="comment">% Compute the patch coordinates and color for the current</span>
                <span class="comment">% link.</span>
                linkSource = obj.GraphData_.Edges.EndNodes(eid, 1);
                linkTarget = obj.GraphData_.Edges.EndNodes(eid, 2);
                linkHeight = obj.GraphData_.Edges.Weight(eid);
                sid = findnode( obj.GraphData_, linkSource );
                tid = findnode( obj.GraphData_, linkTarget );
                sx = obj.XNodeData_(sid) + obj.NodeWidth_;
                sy = obj.YLinkData(eid, 1);
                tx = obj.XNodeData_(tid);
                ty = obj.YLinkData(eid, 2);
                [XX, YY, vColor] = wavyLink( [sx, sy], [tx, ty], <span class="keyword">...</span>
                    linkHeight, obj.Axes.DataAspectRatio, <span class="keyword">...</span>
                    obj.LinkType_, obj.LinkCrossType );

                <span class="comment">% Color the link.</span>
                <span class="keyword">if</span> isscalar( obj.LinkColor_ )
                    <span class="keyword">switch</span> obj.LinkColor_
                        <span class="keyword">case</span> <span class="string">"source"</span>
                            CC = expand( obj.NodeColor_(sid,:) );
                            fColor = <span class="string">"flat"</span>;
                        <span class="keyword">case</span> <span class="string">"target"</span>
                            CC = expand( obj.NodeColor_(tid,:) );
                            fColor = <span class="string">"flat"</span>;
                        <span class="keyword">case</span> <span class="string">"gradient"</span>
                            sColor = expand( obj.NodeColor_(sid,:) );
                            tColor = expand( obj.NodeColor_(tid,:) );
                            CC = (tColor - sColor) .* vColor + sColor;
                            fColor = <span class="string">"interp"</span>;
                    <span class="keyword">end</span> <span class="comment">% switch</span>
                <span class="keyword">else</span>
                    CC = expand( obj.LinkColor_ );
                    fColor = <span class="string">"flat"</span>;
                <span class="keyword">end</span> <span class="comment">% if</span>

                set( obj.LinkPatches(eid), <span class="keyword">...</span>
                    <span class="string">"XData"</span>, XX, <span class="keyword">...</span>
                    <span class="string">"YData"</span>, YY, <span class="keyword">...</span>
                    <span class="string">"CData"</span>, CC, <span class="keyword">...</span>
                    <span class="string">"FaceColor"</span>, fColor, <span class="keyword">...</span>
                    <span class="string">"FaceAlpha"</span>, obj.LinkAlpha, <span class="keyword">...</span>
                    <span class="string">"EdgeAlpha"</span>, obj.LinkAlpha, <span class="keyword">...</span>
                    <span class="string">"EdgeColor"</span>, obj.LinkEdgeColor, <span class="keyword">...</span>
                    <span class="string">"LineWidth"</span>, obj.LinkEdgeWidth, <span class="keyword">...</span>
                    <span class="string">"LineStyle"</span>, obj.LinkEdgeStyle, <span class="keyword">...</span>
                    <span class="string">"Tag"</span>, <span class="string">"Link"</span>, <span class="keyword">...</span>
                    <span class="string">"ButtonDownFcn"</span>, @(~,~) onLinkClicked( obj, eid ) )

            <span class="keyword">end</span> <span class="comment">% for</span>

        <span class="keyword">end</span> <span class="comment">% updateLinks</span>

        <span class="keyword">function</span> updateNodeLabels( obj )
            <span class="comment">%UPDATENODELABELS Helper method to update the node labels.</span>

            nLabels  = obj.GraphData_.numnodes;
            nCurrent = numel( obj.NodeLabels );

            <span class="keyword">if</span> nLabels &lt; nCurrent

                delete( obj.NodeLabels(nLabels+1:nCurrent) )
                obj.NodeLabels(nLabels+1:nCurrent) = [];

            <span class="keyword">elseif</span> nLabels &gt; nCurrent

                <span class="keyword">for</span> nid = nCurrent+1:nLabels
                    obj.NodeLabels(nid) = text( <span class="string">"Parent"</span>, obj.Axes );
                <span class="keyword">end</span> <span class="comment">% for</span>

            <span class="keyword">end</span> <span class="comment">% if</span>

            A = adjacency( obj.GraphData_, <span class="string">"weighted"</span> );
            inflow  = sum( A, 1 )';
            outflow = sum( A, 2 );

            <span class="keyword">for</span> nid = 1:nLabels

                nx = obj.XNodeData_(nid);
                ny = obj.YNodeData_(nid);
                nw = obj.NodeWidth_;
                nh = obj.NodeHeight(nid);

                <span class="keyword">if</span> ismember( <span class="string">"Name"</span>, <span class="keyword">...</span>
                        obj.GraphData_.Nodes.Properties.VariableNames )
                    ns = string( obj.GraphData_.Nodes.Name(nid) );
                <span class="keyword">else</span>
                    ns = string( nid );
                <span class="keyword">end</span> <span class="comment">% if</span>

                <span class="keyword">if</span> obj.LabelIncludeTotal_
                    ni = full( inflow(nid) );
                    no = full( outflow(nid) );
                    <span class="keyword">if</span> ni == no || (ni * no) == 0
                        ns = sprintf( <span class="string">"%s: %g"</span>, ns, nh );
                    <span class="keyword">else</span>
                        ns = sprintf( <span class="string">"%s: %g \\rightarrow %g"</span>, <span class="keyword">...</span>
                            ns, ni, no );
                    <span class="keyword">end</span> <span class="comment">% if</span>
                <span class="keyword">end</span> <span class="comment">% if</span>

                <span class="keyword">switch</span> obj.LabelAlignment_
                    <span class="keyword">case</span> <span class="string">"left"</span>
                        tx = nx;
                        ty = ny + nh/2;
                        hAlign = <span class="string">"right"</span>;
                        vAlign = <span class="string">"middle"</span>;
                    <span class="keyword">case</span> <span class="string">"right"</span>
                        tx = nx + nw;
                        ty = ny + nh/2;
                        hAlign = <span class="string">"left"</span>;
                        vAlign = <span class="string">"middle"</span>;
                    <span class="keyword">case</span> <span class="string">"top"</span>
                        tx = nx + nw/2;
                        ty = ny + nh;
                        hAlign = <span class="string">"center"</span>;
                        vAlign = <span class="string">"bottom"</span>;
                    <span class="keyword">case</span> <span class="string">"bottom"</span>
                        tx = nx + nw/2;
                        ty = ny;
                        hAlign = <span class="string">"center"</span>;
                        vAlign = <span class="string">"top"</span>;
                    <span class="keyword">case</span> <span class="string">"center"</span>
                        tx = nx + nw/2;
                        ty = ny + nh/2;
                        hAlign = <span class="string">"center"</span>;
                        vAlign = <span class="string">"middle"</span>;
                <span class="keyword">end</span> <span class="comment">% switch</span>

                set( obj.NodeLabels(nid), <span class="keyword">...</span>
                    <span class="string">"Position"</span>, [tx, ty], <span class="keyword">...</span>
                    <span class="string">"String"</span>, pad( ns, strlength( ns )+2, <span class="string">"both"</span> ), <span class="keyword">...</span>
                    <span class="string">"HorizontalAlignment"</span>, hAlign, <span class="keyword">...</span>
                    <span class="string">"VerticalAlignment"</span>, vAlign, <span class="keyword">...</span>
                    <span class="string">"Clipping"</span>, <span class="string">"on"</span>, <span class="keyword">...</span>
                    <span class="string">"Tag"</span>, <span class="string">"NodeLabel"</span>, <span class="keyword">...</span>
                    <span class="string">"ButtonDownFcn"</span>, @(~,~) nodeButtonDown( obj, nid ) )

            <span class="keyword">end</span> <span class="comment">% for</span>

        <span class="keyword">end</span> <span class="comment">% updateNodeLabels</span>

        <span class="keyword">function</span> nodeButtonDown( obj, id )

            dimFactor = 8;

            <span class="comment">% Setup when selecting first node</span>
            <span class="keyword">if</span> ~any( obj.NodeSelected )
                <span class="keyword">for</span> nid = 1:obj.GraphData_.numnodes
                    set( obj.NodePatches(nid), <span class="keyword">...</span>
                        <span class="string">"CData"</span>, obj.NodePatches(nid).CData / dimFactor )
                <span class="keyword">end</span> <span class="comment">% for</span>
                <span class="keyword">for</span> eid = 1:obj.GraphData_.numedges
                    set( obj.LinkPatches(eid), <span class="keyword">...</span>
                        <span class="string">"CData"</span>, obj.LinkPatches(eid).CData / dimFactor )
                <span class="keyword">end</span> <span class="comment">% for</span>
            <span class="keyword">end</span> <span class="comment">% if</span>

            I = logical( incidence( obj.GraphData_ )  );

            currentLinks = any( I(obj.NodeSelected,:), 1 );

            obj.NodeSelected(id) = ~obj.NodeSelected(id);

            nextLinks = any( I(obj.NodeSelected,:), 1 );

            <span class="comment">% Making changes for selected node</span>
            <span class="keyword">if</span> obj.NodeSelected(id)

                set( obj.NodePatches(id), <span class="keyword">...</span>
                    <span class="string">"CData"</span>, dimFactor * obj.NodePatches(id).CData )

                eids = find(nextLinks &amp; ~currentLinks);
                <span class="keyword">for</span> k = 1:numel(eids)
                    eid = eids(k);
                    set( obj.LinkPatches(eid), <span class="keyword">...</span>
                        <span class="string">"CData"</span>, dimFactor * obj.LinkPatches(eid).CData )
                <span class="keyword">end</span> <span class="comment">% for</span>

            <span class="keyword">else</span>

                set( obj.NodePatches(id), <span class="keyword">...</span>
                    <span class="string">"CData"</span>, obj.NodePatches(id).CData / dimFactor )

                eids = find(~nextLinks &amp; currentLinks);
                <span class="keyword">for</span> k = 1:numel(eids)
                    eid = eids(k);
                    set( obj.LinkPatches(eid), <span class="keyword">...</span>
                        <span class="string">"CData"</span>, obj.LinkPatches(eid).CData / dimFactor )
                <span class="keyword">end</span> <span class="comment">% for</span>

            <span class="keyword">end</span> <span class="comment">% if</span>

            <span class="comment">% Putting selected labels on top</span>
            obj.Axes.Children(end-obj.GraphData_.numedges+1:end) = [ <span class="keyword">...</span>
                obj.LinkPatches(nextLinks); <span class="keyword">...</span>
                obj.LinkPatches(~nextLinks) ];

            <span class="comment">% Reset colors when no node is selected</span>
            <span class="keyword">if</span> ~any( obj.NodeSelected )
                <span class="keyword">for</span> nid = 1:obj.GraphData_.numnodes
                    set( obj.NodePatches(nid), <span class="keyword">...</span>
                        <span class="string">"CData"</span>, dimFactor * obj.NodePatches(nid).CData )
                <span class="keyword">end</span> <span class="comment">% for</span>
                <span class="keyword">for</span> eid = 1:obj.GraphData_.numedges
                    set( obj.LinkPatches(eid), <span class="keyword">...</span>
                        <span class="string">"CData"</span>, dimFactor * obj.LinkPatches(eid).CData )
                <span class="keyword">end</span> <span class="comment">% for</span>
            <span class="keyword">end</span> <span class="comment">% if</span>

        <span class="keyword">end</span> <span class="comment">% nodeButtonDown</span>

        <span class="keyword">function</span> nodeCoordinates( obj )

            <span class="comment">% Creating hidden figure to get positions</span>
            hiddenFig = figure( <span class="string">"Visible"</span>, <span class="string">"off"</span> );
            oc = onCleanup( @() delete( hiddenFig ) );
            hiddenAx  = axes( hiddenFig );
            hiddenPlt = plot( hiddenAx, obj.GraphData_, <span class="keyword">...</span>
                <span class="string">"Layout"</span>, <span class="string">"layered"</span>, <span class="keyword">...</span>
                <span class="string">"Direction"</span>, <span class="string">"right"</span> );

            <span class="comment">% Retrieving node x-coordinates</span>
            obj.XNodeData_ = hiddenPlt.XData';

            <span class="comment">% Computing node y-coordinates</span>
            xGroups = findgroups( obj.XNodeData_ );

            groupTotFlow = splitapply( @sum, obj.NodeHeight, xGroups );
            groupCount = groupcounts( xGroups );

            nodePad = obj.NodePadRatio_ * max( groupTotFlow );

            obj.YNodeData_ = zeros( obj.GraphData_.numnodes, 1 );
            <span class="keyword">for</span> gid = 1:max( xGroups )
                groupIdx = xGroups == gid;

                [~, yOrdIdx] = sort( hiddenPlt.YData(groupIdx) );
                yOrdIdxInv = 1:groupCount(gid);
                yOrdIdxInv(yOrdIdx) = yOrdIdxInv;

                groupFlows = obj.NodeHeight(groupIdx);
                groupOrdFlows = groupFlows(yOrdIdx);

                groupOrdY = cumsum( groupOrdFlows ) - groupOrdFlows;
                groupY = groupOrdY(yOrdIdxInv);
                padding = nodePad * (yOrdIdxInv' - 1);
                height = groupTotFlow(gid) + max( padding );

                obj.YNodeData_(groupIdx) = groupY + padding - height/2;
            <span class="keyword">end</span> <span class="comment">% for</span>

            updateLinkCoordinates( obj )

        <span class="keyword">end</span> <span class="comment">% nodeCoordinates</span>

        <span class="keyword">function</span> updateNodes( obj )
            <span class="comment">%UPDATENODES Helper method to update the nodes.</span>

            nNodes  = obj.GraphData_.numnodes;
            nCurrent = numel( obj.NodePatches );

            <span class="keyword">if</span> nNodes &lt; nCurrent

                delete( obj.NodePatches(nNodes+1:nCurrent) )
                obj.NodePatches(nNodes+1:nCurrent) = [];

            <span class="keyword">elseif</span> nNodes &gt; nCurrent

                <span class="keyword">for</span> nid = nCurrent+1:nNodes
                    obj.NodePatches(nid) = patch( <span class="string">"Parent"</span>, obj.Axes );
                <span class="keyword">end</span> <span class="comment">% for</span>

            <span class="keyword">end</span> <span class="comment">% if</span>

            expand = @(x) reshape( x, [1, size( x )] );

            <span class="keyword">for</span> nid = 1:nNodes

                nx = obj.XNodeData_(nid);
                ny = obj.YNodeData_(nid);
                nw = obj.NodeWidth_;
                nh = obj.NodeHeight(nid);

                set( obj.NodePatches(nid), <span class="keyword">...</span>
                    <span class="string">"XData"</span>, nx + nw * [0 1 1 0], <span class="keyword">...</span>
                    <span class="string">"YData"</span>, ny + nh * [0 0 1 1], <span class="keyword">...</span>
                    <span class="string">"CData"</span>, expand( obj.NodeColor_(nid,:) ), <span class="keyword">...</span>
                    <span class="string">"FaceColor"</span>, <span class="string">"flat"</span>, <span class="keyword">...</span>
                    <span class="string">"EdgeColor"</span>, obj.NodeEdgeColor, <span class="keyword">...</span>
                    <span class="string">"LineWidth"</span>, obj.NodeEdgeWidth, <span class="keyword">...</span>
                    <span class="string">"LineStyle"</span>, obj.NodeEdgeStyle, <span class="keyword">...</span>
                    <span class="string">"FaceAlpha"</span>, obj.NodeAlpha, <span class="keyword">...</span>
                    <span class="string">"EdgeAlpha"</span>, obj.NodeAlpha, <span class="keyword">...</span>
                    <span class="string">"Tag"</span>, <span class="string">"Node"</span>, <span class="keyword">...</span>
                    <span class="string">"ButtonDownFcn"</span>, @(~,~) nodeButtonDown( obj, nid ) )

            <span class="keyword">end</span> <span class="comment">% for</span>

        <span class="keyword">end</span> <span class="comment">% updateNodes</span>

    <span class="keyword">end</span> <span class="comment">% methods</span>

    <span class="keyword">methods</span> ( Access = protected )

        <span class="keyword">function</span> setup( obj )
            <span class="comment">%SETUP Initialize the chart graphics.</span>

            <span class="comment">% Create the axes.</span>
            obj.Axes = axes( <span class="string">"Parent"</span>, obj.getLayout(), <span class="keyword">...</span>
                <span class="string">"Visible"</span>, <span class="string">"off"</span>, <span class="keyword">...</span>
                <span class="string">"DataAspectRatioMode"</span>, <span class="string">"manual"</span> );
            obj.Axes.Title.Visible = <span class="string">"on"</span>;
            disableDefaultInteractivity( obj.Axes )

        <span class="keyword">end</span> <span class="comment">% setup</span>

        <span class="keyword">function</span> update( obj )
            <span class="comment">%UPDATE Refresh the chart graphics.</span>

            <span class="keyword">if</span> obj.ComputationRequired

                <span class="comment">% Set optimal data aspect ratio.</span>
                rangeX = range( [obj.XNodeData_; obj.XNodeData_ + <span class="keyword">...</span>
                    obj.NodeWidth_] );
                rangeY = range( [obj.YNodeData_; obj.YNodeData_ + <span class="keyword">...</span>
                    obj.NodeHeight] );
                obj.Axes.DataAspectRatio = [rangeX, rangeY, 1];

                <span class="comment">% Display links.</span>
                updateLinks( obj )

                <span class="comment">% Display nodes.</span>
                updateNodes( obj )

                <span class="comment">% Display node names.</span>
                updateNodeLabels( obj )

                <span class="comment">% Create link labels.</span>
                updateLinkLabels( obj )

                <span class="comment">% Reset the node selected state.</span>
                obj.NodeSelected = false( size( obj.NodeSelected ) );

                <span class="comment">% Ensuring correct ordering.</span>
                obj.Axes.Children = [  obj.LinkLabels; <span class="keyword">...</span>
                    obj.NodeLabels; <span class="keyword">...</span>
                    obj.NodePatches; <span class="keyword">...</span>
                    obj.LinkPatches ];

                <span class="comment">% Reset the flag.</span>
                obj.ComputationRequired = false;

            <span class="keyword">end</span> <span class="comment">% if</span>

            <span class="comment">% Refresh the chart's decorative properties.</span>
            set( obj.LinkPatches, <span class="keyword">...</span>
                <span class="string">"FaceAlpha"</span>, obj.LinkAlpha, <span class="keyword">...</span>
                <span class="string">"EdgeAlpha"</span>, obj.LinkAlpha, <span class="keyword">...</span>
                <span class="string">"EdgeColor"</span>, obj.LinkEdgeColor, <span class="keyword">...</span>
                <span class="string">"LineStyle"</span>, obj.LinkEdgeStyle, <span class="keyword">...</span>
                <span class="string">"LineWidth"</span>, obj.LinkEdgeWidth )

            set( obj.NodePatches, <span class="keyword">...</span>
                <span class="string">"FaceAlpha"</span>, obj.NodeAlpha, <span class="keyword">...</span>
                <span class="string">"EdgeAlpha"</span>, obj.NodeAlpha, <span class="keyword">...</span>
                <span class="string">"EdgeColor"</span>, obj.NodeEdgeColor, <span class="keyword">...</span>
                <span class="string">"LineStyle"</span>, obj.NodeEdgeStyle, <span class="keyword">...</span>
                <span class="string">"LineWidth"</span>, obj.NodeEdgeWidth )

            set( obj.NodeLabels, <span class="keyword">...</span>
                <span class="string">"FontSize"</span>, obj.NodeFontSize, <span class="keyword">...</span>
                <span class="string">"Visible"</span>, obj.NodeLabelsVisible )

            set( obj.LinkLabels, <span class="keyword">...</span>
                <span class="string">"FontSize"</span>, obj.LinkFontSize)

        <span class="keyword">end</span> <span class="comment">% update</span>

    <span class="keyword">end</span> <span class="comment">% methods ( Access = protected )</span>

<span class="keyword">end</span> <span class="comment">% classdef</span>

<span class="keyword">function</span> [XX, YY, CC] = wavyLink( startPoint, endPoint, <span class="keyword">...</span>
    girth, ratio, type, crossSection, n )
<span class="comment">%WAVYLINK Compute the (x, y) coordinates and color of the wavy link</span>
<span class="comment">%connecting two nodes.</span>

<span class="keyword">arguments</span> ( Input )
    startPoint<span class="typesection">(1, 2) double</span>
    endPoint<span class="typesection">(1, 2) double</span>
    girth<span class="typesection">(1, 1) double {mustBeNonnegative, mustBeFinite}</span>
    ratio<span class="typesection">(1, 3) double </span>= [1, 1, 1]
    type<span class="typesection">(1, 1) string </span><span class="keyword">...</span>
        <span class="typesection">{mustBeMember( type, ["tanh", "cos", "line"] )}</span> = <span class="string">"cos"</span>
    crossSection<span class="typesection">(1, 1) string {mustBeMember( crossSection, </span><span class="keyword">...</span>
        <span class="typesection">["normal", "vertical"] )}</span> = <span class="string">"normal"</span>
    n<span class="typesection">(1, 1) double {mustBeGreaterThan( n, 1 )}</span> = 32
<span class="keyword">end</span> <span class="comment">% arguments ( Input )</span>

width  = endPoint(1) - startPoint(1);
height = endPoint(2) - startPoint(2);

<span class="comment">% Creating patch</span>
<span class="keyword">if</span> width &gt; 0
    [XX, YY] = forwardLink();
<span class="keyword">else</span>
    [XX, YY] = backwardsLink();
<span class="keyword">end</span> <span class="comment">% if</span>

<span class="comment">% Ensure simple (Jordan) polygons</span>
warnID = <span class="string">"MATLAB:polyshape:repairedBySimplify"</span>;
warnState = warning( <span class="string">"query"</span>, warnID );
warning( <span class="string">"off"</span>, warnID )
warnCleanup = onCleanup( @() warning( warnState ) );
poly = polyshape( XX, YY );
poly = rmholes( poly );
XX = poly.Vertices(:, 1);
YY = poly.Vertices(:, 2);
NN = numel(XX);
CC = - abs( (2 * linspace( 0, NN, NN ) - NN ) / NN ) + 1;

    <span class="keyword">function</span> [XX, YY] = forwardLink()

        <span class="comment">% Creating reference function ([0,1] -&gt; [0,1]) and derivative</span>
        <span class="keyword">switch</span> type
            <span class="keyword">case</span> <span class="string">"tanh"</span>
                curvy = 4;
                g  = @(x) (tanh( curvy * (2 * x - 1) ) + <span class="keyword">...</span>
                    tanh(curvy)) / (2 * tanh(curvy));
                dg = @(x) curvy * sech( curvy * <span class="keyword">...</span>
                    (2 * x - 1) ).^2 / tanh(curvy);
            <span class="keyword">case</span> <span class="string">"cos"</span>
                g  = @(x) (1 - cos( pi * x )) / 2;
                dg = @(x) pi * sin( pi * x ) /2;
            <span class="keyword">case</span> <span class="string">"line"</span>
                n = 2;
                g  = @(x) x;
                dg = @(x) ones( size( x ) );
        <span class="keyword">end</span> <span class="comment">% switch/case</span>

        <span class="comment">% Enabling vertical cross sections</span>
        <span class="keyword">if</span> crossSection == <span class="string">"vertical"</span>
            dg = @(x) zeros( size( x ) );
        <span class="keyword">end</span> <span class="comment">% if</span>

        <span class="comment">% Scaling function to desired size</span>
        f  = @(x) height * g( x / width );
        df = @(x) height * dg( x / width ) / width;

        <span class="comment">% Computing reference line</span>
        x0 = linspace( 0, width, n );
        y0 = f( x0 );

        <span class="comment">% Computing normal vectors at each point</span>
        rr = ratio(1) / ratio(2);
        delta = [df(x0); - ones( size( x0 ) ) / rr];
        delta = girth * diag( [rr, 1] ) * delta ./ vecnorm( delta ) / 2;

        <span class="comment">% Taking points on each side of reference line</span>
        x1 = x0 + delta(1, :);
        y1 = y0 + delta(2, :);

        x2 = x0 - delta(1, :);
        y2 = y0 - delta(2, :);

        <span class="comment">% Cleaning up sides</span>
        x1(1) = 0;
        x2(1) = 0;

        x1(end) = width;
        x2(end) = width;

        <span class="keyword">if</span> width &gt; 0
            before1 = x1 &lt;= 0;
            before2 = x2 &lt;= 0;
            after1  = x1 &gt;= width;
            after2  = x2 &gt;= width;
        <span class="keyword">else</span>
            before1 = x1 &gt;= 0;
            before2 = x2 &gt;= 0;
            after1  = x1 &lt;= width;
            after2  = x2 &lt;= width;
        <span class="keyword">end</span> <span class="comment">% if</span>

        x1(before1) = 0;
        y1(before1) = - girth / 2;

        x2(before2) = 0;
        y2(before2) = girth / 2;

        x1(after1) = width;
        y1(after1) = height - girth / 2;

        x2(after2) = width;
        y2(after2) = height + girth / 2;

        XX = startPoint(1) + [x1 fliplr(x2)];
        YY = startPoint(2) + [y1 fliplr(y2)] + girth / 2;

    <span class="keyword">end</span> <span class="comment">% forwardLink</span>

    <span class="keyword">function</span> [XX, YY] = backwardsLink()

        A = 0.1;
        B = A + girth * ratio(1) / ratio(2);
        C = -girth;
        <span class="keyword">if</span> height &lt; 0
            C = C + height;
        <span class="keyword">end</span>

        XX = [0, A, A, width-A, width-A, width, <span class="keyword">...</span>
            width, width-B, width-B, B, B, 0];
        YY = [0, 0, C, C, height, height, <span class="keyword">...</span>
            height+girth, height+girth, C-girth, C-girth, girth, girth];

        XX = startPoint(1) + XX;
        YY = startPoint(2) + YY;

    <span class="keyword">end</span> <span class="comment">% backwardsLink</span>

<span class="keyword">end</span> <span class="comment">% wavyLink</span>
</pre>
</div>
<!--
##### SOURCE BEGIN #####
classdef SankeyChart < Chart
    %SANKEYCHART Illustrate the flow between different states.

    % Copyright 2018-2025 The MathWorks, Inc.

    properties ( Dependent )
        % Directed graph representing the Sankey diagram.
        GraphData(1, 1) digraph
        % Node label alignment.
        LabelAlignment(1, 1) string {mustBeMember( LabelAlignment, ...
            ["left", "right", "top", "bottom", "center"] )}
        % Flag to display totals.
        LabelIncludeTotal(1, 1) matlab.lang.OnOffSwitchState
        % Link color.
        LinkColor
        % Curve type.
        LinkType(1, 1) string {mustBeMember( LinkType, ...
            ["tanh", "cos", "vtanh", "vcos", "line"] )}
        % Node color.
        NodeColor
        % Vertical space between nodes.
        NodePadRatio(1, 1) double {mustBeNonnegative, mustBeFinite}
        % Node width.
        NodeWidth(1, 1) double {mustBeNonnegative, mustBeFinite}
        % Node x-coordinates.
        XNodeData(:, 1) double {mustBeReal, mustBeFinite}
        % Node y-coordinates.
        YNodeData(:, 1) double {mustBeReal, mustBeFinite}
    end % properties ( Dependent )

    properties
        % Link transparency.
        LinkAlpha(1, 1) double {mustBeInRange( LinkAlpha, 0, 1 )} = 0.5
        % Link edge color.
        LinkEdgeColor {validatecolor} = "black"
        % Link edge style.
        LinkEdgeStyle(1, 1) string {mustBeLineStyle} = "none"
        % Link edge width.
        LinkEdgeWidth(1, 1) double {mustBePositive, mustBeFinite} = 0.5
        % Font size for link annotations.
        LinkFontSize(1, 1) double {mustBePositive, mustBeFinite} = 10
        % Node transparency.
        NodeAlpha(1, 1) double {mustBeInRange( NodeAlpha, 0, 1 )} = 1
        % Node edge color.
        NodeEdgeColor {validatecolor} = "black"
        % Node edge line style.
        NodeEdgeStyle(1, 1) string {mustBeLineStyle} = "-"
        % Node edge width.
        NodeEdgeWidth(1, 1) double {mustBePositive, mustBeFinite} = 0.5
        % Node label font size.
        NodeFontSize(1, 1) double {mustBePositive, mustBeFinite} = 10
        % Node label visibility.
        NodeLabelsVisible(1, 1) matlab.lang.OnOffSwitchState = "on"
    end % properties

    properties ( Access = private, Transient, NonCopyable )
        % The chart's axes.
        Axes(:, 1) matlab.graphics.axis.Axes {mustBeScalarOrEmpty}
        % Text objects for the link labels.
        LinkLabels(:, 1) matlab.graphics.primitive.Text
        % Patch objects for the links.
        LinkPatches(:, 1) matlab.graphics.primitive.Patch
        % Text objects for the node labels.
        NodeLabels(:, 1) matlab.graphics.primitive.Text
        % Patch objects for the nodes.
        NodePatches(:, 1) matlab.graphics.primitive.Patch
    end % properties ( Access = private, Transient, NonCopyable )

    properties ( Access = private )
        % Logical scalar specifying whether a computation is required.
        ComputationRequired(1, 1) logical = false
        % Backing for LabelAlignment.
        LabelAlignment_(1, 1) string {mustBeMember( LabelAlignment_, ...
            ["left", "right", "top", "bottom", "center"] )} = "right"
        % Backing for LabelIncludeTotal.
        LabelIncludeTotal_(1, 1) matlab.lang.OnOffSwitchState = "off"
        % Backing for LinkColor.
        LinkColor_ = "source"
        % Backing for LinkType.
        LinkType_(1, 1) string {mustBeMember( LinkType_, ...
            ["tanh", "cos", "vtanh", "vcos", "line"] )} = "cos"
        % Link cross type.
        LinkCrossType(1, 1) string {mustBeMember( LinkCrossType, ...
            ["vertical", "normal"] )} = "normal"
        % Backing for GraphData.
        GraphData_(1, 1) digraph = digraph()
        % Backing for NodeColor.
        NodeColor_ = zeros( 0, 3 )
        % Node height.
        NodeHeight(:, 1) double {mustBePositive, mustBeFinite} = ...
            double.empty( 0, 1 )
        % Backing for NodePadRatio.
        NodePadRatio_(1, 1) double {mustBeNonnegative, mustBeFinite} = 0.05
        % Logical array indicating whether nodes are selected.
        NodeSelected(:, 1) logical = false( 0, 1 )
        % Backing for NodeWidth.
        NodeWidth_(1, 1) double {mustBeNonnegative, mustBeFinite} = 0.1
        % Backing for XNodeData.
        XNodeData_(:, 1) double {mustBeReal, mustBeFinite} = zeros( 0, 1 )
        % Backing for YNodeData.
        YNodeData_(:, 1) double {mustBeReal, mustBeFinite} = zeros( 0, 1 )
        % Y link data.
        YLinkData(:, :) double {mustBeReal, mustBeFinite} = zeros( 0, 1 )
    end % properties ( Access = private )

    properties ( Constant, Hidden )
        % Product dependencies.
        Dependencies(1, :) string = "MATLAB"
        % Description.
        ShortDescription(1, 1) string = "Illustrate the flow between" + ...
            " different states"
    end % properties ( Constant, Hidden )

    methods

        function obj = SankeyChart( namedArgs )
            %SANKEYCHART Construct a SankeyChart, given optional name-value
            %arguments.

            arguments ( Input )
                namedArgs.?SankeyChart
            end % arguments ( Input )            

            % Set any user-defined properties.
            set( obj, namedArgs )

        end % constructor

        function set.LabelAlignment( obj, value )

            obj.LabelAlignment_ = value;
            updateNodeLabels( obj )

        end % set.LabelAlignment

        function value = get.LabelAlignment( obj )

            value = obj.LabelAlignment_;

        end % get.LabelAlignment

        function set.LabelIncludeTotal( obj, value )

            obj.LabelIncludeTotal_ = value;
            updateNodeLabels( obj )

        end % set.LabelIncludeTotal

        function value = get.LabelIncludeTotal( obj )

            value = obj.LabelIncludeTotal_;

        end % get.LabelIncludeTotal

        function set.LinkColor( obj, value )

            % Validate.
            value = convertCharsToStrings( value );
            if ~isstring( value ) || ~ismember( value, ...
                    ["source", "target", "gradient"] )
                value = validatecolor( value );
            end % if

            % Update.
            obj.ComputationRequired = true;
            obj.LinkColor_ = value;

        end % set.LinkColor

        function value = get.LinkColor( obj )

            value = obj.LinkColor_;

        end % get.LinkColor

        function set.LinkType( obj, value )

            obj.ComputationRequired = true;

            pat = "v";
            if startsWith( value, pat )
                obj.LinkType_ = extractBetween( value, pat, ...
                    textBoundary( "end" ) );
                obj.LinkCrossType = "vertical";
            else
                obj.LinkType_ = value;
                obj.LinkCrossType = "normal";
            end % if

        end % set.LinkType

        function value = get.LinkType( obj )

            if obj.LinkCrossType == "vertical"
                value = "v" + obj.LinkType_;
            else
                value = obj.LinkType_;
            end % if

        end % get.LinkType

        function set.GraphData( obj, value )

            % Check.
            if ismultigraph( value ) || ...
                    any( diag( adjacency( obj.GraphData_ ) ) )
                error( "SankeyChart:NotSimpleGraph", ...
                    "The given graph is not simple. Use simplify to " + ...
                    "remove multiple edges and self-loops." )
            end % if

            % Update internal properties.
            obj.ComputationRequired = true;
            obj.GraphData_ = value;

            % Making sure weights are specified.
            if ~ismember( "Weight", ...
                    obj.GraphData_.Edges.Properties.VariableNames )
                obj.GraphData_.Edges.Weight = ...
                    ones( obj.GraphData_.numedges, 1 );
            end % if

            % Compute node flows.
            A = adjacency( obj.GraphData_, "weighted" );
            inflow  = sum( A, 1 )';
            outflow = sum( A, 2 );
            src = inflow == 0;
            snk = outflow == 0;

            % Issue a warning for unbalanced graphs.
            if ~isequal( inflow(~src & ~snk), outflow(~src & ~snk) )
                warning( "SankeyChart:UnbalancedGraph", ...
                    "The given graph is unbalanced." )
            end % if

            % Compute node and link coordinates.
            obj.NodeHeight = full( max( inflow, outflow ) );
            nodeCoordinates( obj )

            % Set node colors.
            obj.NodeColor_ = lines( obj.GraphData_.numnodes );

            % Update the selection.
            obj.NodeSelected = false( obj.GraphData_.numnodes, 1 );

        end % set.GraphData

        function value = get.GraphData( obj )

            value = obj.GraphData_;

        end % get.GraphData

        function set.NodeColor( obj, value )

            % Check.
            nodeColor = validatecolor( value, "multiple" );
            validateattributes( nodeColor, "double", ...
                {"size", size( obj.NodeColor_ )} )

            % Update.
            obj.ComputationRequired = true;
            obj.NodeColor_ = nodeColor;

        end % set.NodeColor

        function value = get.NodeColor( obj )

            value = obj.NodeColor_;

        end % get.NodeColor

        function set.NodePadRatio( obj, value )

            obj.ComputationRequired = true;
            obj.NodePadRatio_ = value;
            nodeCoordinates( obj )

        end % set.NodePadRatio

        function value = get.NodePadRatio( obj )

            value = obj.NodePadRatio_;

        end % get.NodePadRatio

        function set.NodeWidth( obj, value )

            obj.ComputationRequired = true;
            obj.NodeWidth_ = value;

        end % set.NodeWidth

        function value = get.NodeWidth( obj )

            value = obj.NodeWidth_;

        end % get.NodeWidth

        function set.XNodeData( obj, value )

            % Check.
            validateattributes( value, "double", ...
                {"size", size( obj.XNodeData_ )} )

            % Update.
            obj.ComputationRequired = true;
            obj.XNodeData_ = value;

        end % set.XNodeData

        function value = get.XNodeData( obj )

            value = obj.XNodeData_;

        end % get.XNodeData

        function set.YNodeData( obj, value )

            % Check.
            validateattributes( value, "double", ...
                {"size", size( obj.YNodeData_ )} )

            % Update.
            obj.ComputationRequired = true;
            obj.YNodeData_ = value;

            % Recompute link coordinates.
            updateLinkCoordinates( obj )

        end % set.YNodeData

        function value = get.YNodeData( obj )

            value = obj.YNodeData_;

        end % get.YNodeData

    end % methods

    methods

        function varargout = title( obj, varargin )

            [varargout{1:nargout}] = title( obj.Axes, varargin{:} );

        end % title

    end % methods

    methods ( Access = private )

        function updateLinkLabels( obj )
            %UPDATELINKLABELS Helper method to update the link labels.

            nLabels  = obj.GraphData_.numedges;
            nCurrent = numel( obj.LinkLabels );

            if nLabels < nCurrent

                delete( obj.LinkLabels(nLabels+1:nCurrent) )
                obj.LinkLabels(nLabels+1:nCurrent) = [];

            elseif nLabels > nCurrent

                for eid = nCurrent+1:nLabels
                    obj.LinkLabels(eid) = text( "Parent", obj.Axes );
                end % for

            end % if

            for eid = 1:nLabels

                linkSource = obj.GraphData_.Edges.EndNodes(eid, 1);
                linkTarget = obj.GraphData_.Edges.EndNodes(eid, 2);
                linkHeight = obj.GraphData_.Edges.Weight(eid);

                linkText = [sprintf( "Source: %s", ...
                    string( linkSource ) ), ...
                    sprintf( "Target: %s", string( linkTarget ) ), ...
                    sprintf( "Weight: %g", linkHeight )];

                textX = mean( obj.LinkPatches(eid).XData );
                textY = mean( obj.LinkPatches(eid).YData );

                set( obj.LinkLabels(eid), ...
                    "Position", [textX, textY], ...
                    "String", linkText, ...
                    "HorizontalAlignment", "center", ...
                    "VerticalAlignment", "middle", ...
                    "BackgroundColor", [1, 1, 1, 0.25], ...
                    "Margin", 1, ...
                    "Visible", "off", ...
                    "Clipping", "on", ...
                    "Tag", "LinkLabel", ...
                    "ButtonDownFcn", @(~, ~) onLinkClicked( obj, eid ) )

            end % for

        end % updateLinkLabels

        function onLinkClicked( obj, id )
            %ONLINKCLICKED Link left-click callback.

            set( obj.LinkLabels(id), ...
                "Visible", ~obj.LinkLabels(id).Visible )

        end % onLinkClicked

        function updateLinkCoordinates( obj )
            %UPDATELINKCOORDINATES Helper method to update the link
            %coordinates.

            % Compute link y-coordinates.
            obj.YLinkData = zeros( obj.GraphData_.numedges, 2 );

            for nid = 1:obj.GraphData_.numnodes

                % Outbound links
                [eid, tid] = outedges( obj.GraphData_, nid );
                targetY = obj.YNodeData_(tid) + obj.NodeHeight(tid)/2;
                [~, yOrdIdx] = sort( targetY );
                linkHeight = obj.GraphData_.Edges.Weight(eid(yOrdIdx));
                linkY = cumsum( linkHeight ) - linkHeight;
                obj.YLinkData(eid(yOrdIdx), 1) = ...
                    obj.YNodeData_(nid) + linkY;

                % Inbound links
                [eid, sid] = inedges( obj.GraphData_, nid );
                sourceY = obj.YNodeData_(sid) + obj.NodeHeight(sid)/2;
                [~, yOrdIdx] = sort( sourceY );
                linkHeight = obj.GraphData_.Edges.Weight(eid(yOrdIdx));
                linkY = cumsum( linkHeight ) - linkHeight;
                obj.YLinkData(eid(yOrdIdx), 2) = ...
                    obj.YNodeData_(nid) + linkY;

            end % for

        end % updateLinkCoordinates

        function updateLinks( obj )
            %UPDATELINKS Helper method to update links.

            nLinks   = obj.GraphData_.numedges;
            nCurrent = numel( obj.LinkPatches );

            if nLinks < nCurrent

                delete( obj.LinkPatches(nLinks+1:nCurrent) )
                obj.LinkPatches(nLinks+1:nCurrent) = [];

            elseif nLinks > nCurrent

                for eid = nCurrent+1:nLinks
                    obj.LinkPatches(eid) = patch( "Parent", obj.Axes );
                end % for

            end % if

            expand = @(x) reshape( x, [1, size( x )] );

            for eid = 1:nLinks

                % Compute the patch coordinates and color for the current
                % link.
                linkSource = obj.GraphData_.Edges.EndNodes(eid, 1);
                linkTarget = obj.GraphData_.Edges.EndNodes(eid, 2);
                linkHeight = obj.GraphData_.Edges.Weight(eid);
                sid = findnode( obj.GraphData_, linkSource );
                tid = findnode( obj.GraphData_, linkTarget );
                sx = obj.XNodeData_(sid) + obj.NodeWidth_;
                sy = obj.YLinkData(eid, 1);
                tx = obj.XNodeData_(tid);
                ty = obj.YLinkData(eid, 2);
                [XX, YY, vColor] = wavyLink( [sx, sy], [tx, ty], ...
                    linkHeight, obj.Axes.DataAspectRatio, ...
                    obj.LinkType_, obj.LinkCrossType );

                % Color the link.
                if isscalar( obj.LinkColor_ )
                    switch obj.LinkColor_
                        case "source"
                            CC = expand( obj.NodeColor_(sid,:) );
                            fColor = "flat";
                        case "target"
                            CC = expand( obj.NodeColor_(tid,:) );
                            fColor = "flat";
                        case "gradient"
                            sColor = expand( obj.NodeColor_(sid,:) );
                            tColor = expand( obj.NodeColor_(tid,:) );
                            CC = (tColor - sColor) .* vColor + sColor;
                            fColor = "interp";
                    end % switch
                else
                    CC = expand( obj.LinkColor_ );
                    fColor = "flat";
                end % if

                set( obj.LinkPatches(eid), ...
                    "XData", XX, ...
                    "YData", YY, ...
                    "CData", CC, ...
                    "FaceColor", fColor, ...
                    "FaceAlpha", obj.LinkAlpha, ...
                    "EdgeAlpha", obj.LinkAlpha, ...
                    "EdgeColor", obj.LinkEdgeColor, ...
                    "LineWidth", obj.LinkEdgeWidth, ...
                    "LineStyle", obj.LinkEdgeStyle, ...
                    "Tag", "Link", ...
                    "ButtonDownFcn", @(~,~) onLinkClicked( obj, eid ) )

            end % for

        end % updateLinks

        function updateNodeLabels( obj )
            %UPDATENODELABELS Helper method to update the node labels.

            nLabels  = obj.GraphData_.numnodes;
            nCurrent = numel( obj.NodeLabels );

            if nLabels < nCurrent

                delete( obj.NodeLabels(nLabels+1:nCurrent) )
                obj.NodeLabels(nLabels+1:nCurrent) = [];

            elseif nLabels > nCurrent

                for nid = nCurrent+1:nLabels
                    obj.NodeLabels(nid) = text( "Parent", obj.Axes );
                end % for

            end % if

            A = adjacency( obj.GraphData_, "weighted" );
            inflow  = sum( A, 1 )';
            outflow = sum( A, 2 );

            for nid = 1:nLabels

                nx = obj.XNodeData_(nid);
                ny = obj.YNodeData_(nid);
                nw = obj.NodeWidth_;
                nh = obj.NodeHeight(nid);

                if ismember( "Name", ...
                        obj.GraphData_.Nodes.Properties.VariableNames )
                    ns = string( obj.GraphData_.Nodes.Name(nid) );
                else
                    ns = string( nid );
                end % if

                if obj.LabelIncludeTotal_
                    ni = full( inflow(nid) );
                    no = full( outflow(nid) );
                    if ni == no || (ni * no) == 0
                        ns = sprintf( "%s: %g", ns, nh );
                    else
                        ns = sprintf( "%s: %g \\rightarrow %g", ...
                            ns, ni, no );
                    end % if
                end % if

                switch obj.LabelAlignment_
                    case "left"
                        tx = nx;
                        ty = ny + nh/2;
                        hAlign = "right";
                        vAlign = "middle";
                    case "right"
                        tx = nx + nw;
                        ty = ny + nh/2;
                        hAlign = "left";
                        vAlign = "middle";
                    case "top"
                        tx = nx + nw/2;
                        ty = ny + nh;
                        hAlign = "center";
                        vAlign = "bottom";
                    case "bottom"
                        tx = nx + nw/2;
                        ty = ny;
                        hAlign = "center";
                        vAlign = "top";
                    case "center"
                        tx = nx + nw/2;
                        ty = ny + nh/2;
                        hAlign = "center";
                        vAlign = "middle";
                end % switch

                set( obj.NodeLabels(nid), ...
                    "Position", [tx, ty], ...
                    "String", pad( ns, strlength( ns )+2, "both" ), ...
                    "HorizontalAlignment", hAlign, ...
                    "VerticalAlignment", vAlign, ...
                    "Clipping", "on", ...
                    "Tag", "NodeLabel", ...
                    "ButtonDownFcn", @(~,~) nodeButtonDown( obj, nid ) )

            end % for

        end % updateNodeLabels

        function nodeButtonDown( obj, id )

            dimFactor = 8;

            % Setup when selecting first node
            if ~any( obj.NodeSelected )
                for nid = 1:obj.GraphData_.numnodes
                    set( obj.NodePatches(nid), ...
                        "CData", obj.NodePatches(nid).CData / dimFactor )
                end % for
                for eid = 1:obj.GraphData_.numedges
                    set( obj.LinkPatches(eid), ...
                        "CData", obj.LinkPatches(eid).CData / dimFactor )
                end % for
            end % if

            I = logical( incidence( obj.GraphData_ )  );

            currentLinks = any( I(obj.NodeSelected,:), 1 );

            obj.NodeSelected(id) = ~obj.NodeSelected(id);

            nextLinks = any( I(obj.NodeSelected,:), 1 );

            % Making changes for selected node
            if obj.NodeSelected(id)

                set( obj.NodePatches(id), ...
                    "CData", dimFactor * obj.NodePatches(id).CData )

                eids = find(nextLinks & ~currentLinks);
                for k = 1:numel(eids)
                    eid = eids(k);
                    set( obj.LinkPatches(eid), ...
                        "CData", dimFactor * obj.LinkPatches(eid).CData )
                end % for

            else

                set( obj.NodePatches(id), ...
                    "CData", obj.NodePatches(id).CData / dimFactor )

                eids = find(~nextLinks & currentLinks);
                for k = 1:numel(eids)
                    eid = eids(k);
                    set( obj.LinkPatches(eid), ...
                        "CData", obj.LinkPatches(eid).CData / dimFactor )
                end % for

            end % if

            % Putting selected labels on top
            obj.Axes.Children(end-obj.GraphData_.numedges+1:end) = [ ...
                obj.LinkPatches(nextLinks); ...
                obj.LinkPatches(~nextLinks) ];

            % Reset colors when no node is selected
            if ~any( obj.NodeSelected )
                for nid = 1:obj.GraphData_.numnodes
                    set( obj.NodePatches(nid), ...
                        "CData", dimFactor * obj.NodePatches(nid).CData )
                end % for
                for eid = 1:obj.GraphData_.numedges
                    set( obj.LinkPatches(eid), ...
                        "CData", dimFactor * obj.LinkPatches(eid).CData )
                end % for
            end % if

        end % nodeButtonDown

        function nodeCoordinates( obj )

            % Creating hidden figure to get positions
            hiddenFig = figure( "Visible", "off" );
            oc = onCleanup( @() delete( hiddenFig ) );
            hiddenAx  = axes( hiddenFig );
            hiddenPlt = plot( hiddenAx, obj.GraphData_, ...
                "Layout", "layered", ...
                "Direction", "right" );

            % Retrieving node x-coordinates
            obj.XNodeData_ = hiddenPlt.XData';

            % Computing node y-coordinates
            xGroups = findgroups( obj.XNodeData_ );

            groupTotFlow = splitapply( @sum, obj.NodeHeight, xGroups );
            groupCount = groupcounts( xGroups );

            nodePad = obj.NodePadRatio_ * max( groupTotFlow );

            obj.YNodeData_ = zeros( obj.GraphData_.numnodes, 1 );
            for gid = 1:max( xGroups )
                groupIdx = xGroups == gid;

                [~, yOrdIdx] = sort( hiddenPlt.YData(groupIdx) );
                yOrdIdxInv = 1:groupCount(gid);
                yOrdIdxInv(yOrdIdx) = yOrdIdxInv;

                groupFlows = obj.NodeHeight(groupIdx);
                groupOrdFlows = groupFlows(yOrdIdx);

                groupOrdY = cumsum( groupOrdFlows ) - groupOrdFlows;
                groupY = groupOrdY(yOrdIdxInv);
                padding = nodePad * (yOrdIdxInv' - 1);
                height = groupTotFlow(gid) + max( padding );

                obj.YNodeData_(groupIdx) = groupY + padding - height/2;
            end % for

            updateLinkCoordinates( obj )

        end % nodeCoordinates

        function updateNodes( obj )
            %UPDATENODES Helper method to update the nodes.

            nNodes  = obj.GraphData_.numnodes;
            nCurrent = numel( obj.NodePatches );

            if nNodes < nCurrent

                delete( obj.NodePatches(nNodes+1:nCurrent) )
                obj.NodePatches(nNodes+1:nCurrent) = [];

            elseif nNodes > nCurrent

                for nid = nCurrent+1:nNodes
                    obj.NodePatches(nid) = patch( "Parent", obj.Axes );
                end % for

            end % if

            expand = @(x) reshape( x, [1, size( x )] );

            for nid = 1:nNodes

                nx = obj.XNodeData_(nid);
                ny = obj.YNodeData_(nid);
                nw = obj.NodeWidth_;
                nh = obj.NodeHeight(nid);

                set( obj.NodePatches(nid), ...
                    "XData", nx + nw * [0 1 1 0], ...
                    "YData", ny + nh * [0 0 1 1], ...
                    "CData", expand( obj.NodeColor_(nid,:) ), ...
                    "FaceColor", "flat", ...
                    "EdgeColor", obj.NodeEdgeColor, ...
                    "LineWidth", obj.NodeEdgeWidth, ...
                    "LineStyle", obj.NodeEdgeStyle, ...
                    "FaceAlpha", obj.NodeAlpha, ...
                    "EdgeAlpha", obj.NodeAlpha, ...
                    "Tag", "Node", ...
                    "ButtonDownFcn", @(~,~) nodeButtonDown( obj, nid ) )

            end % for

        end % updateNodes

    end % methods

    methods ( Access = protected )

        function setup( obj )
            %SETUP Initialize the chart graphics.

            % Create the axes.
            obj.Axes = axes( "Parent", obj.getLayout(), ...
                "Visible", "off", ...
                "DataAspectRatioMode", "manual" );
            obj.Axes.Title.Visible = "on";
            disableDefaultInteractivity( obj.Axes )

        end % setup

        function update( obj )
            %UPDATE Refresh the chart graphics.

            if obj.ComputationRequired

                % Set optimal data aspect ratio.
                rangeX = range( [obj.XNodeData_; obj.XNodeData_ + ...
                    obj.NodeWidth_] );
                rangeY = range( [obj.YNodeData_; obj.YNodeData_ + ...
                    obj.NodeHeight] );
                obj.Axes.DataAspectRatio = [rangeX, rangeY, 1];

                % Display links.
                updateLinks( obj )

                % Display nodes.
                updateNodes( obj )

                % Display node names.
                updateNodeLabels( obj )

                % Create link labels.
                updateLinkLabels( obj )

                % Reset the node selected state.
                obj.NodeSelected = false( size( obj.NodeSelected ) );

                % Ensuring correct ordering.
                obj.Axes.Children = [  obj.LinkLabels; ...
                    obj.NodeLabels; ...
                    obj.NodePatches; ...
                    obj.LinkPatches ];

                % Reset the flag.
                obj.ComputationRequired = false;

            end % if

            % Refresh the chart's decorative properties.
            set( obj.LinkPatches, ...
                "FaceAlpha", obj.LinkAlpha, ...
                "EdgeAlpha", obj.LinkAlpha, ...
                "EdgeColor", obj.LinkEdgeColor, ...
                "LineStyle", obj.LinkEdgeStyle, ...
                "LineWidth", obj.LinkEdgeWidth )

            set( obj.NodePatches, ...
                "FaceAlpha", obj.NodeAlpha, ...
                "EdgeAlpha", obj.NodeAlpha, ...
                "EdgeColor", obj.NodeEdgeColor, ...
                "LineStyle", obj.NodeEdgeStyle, ...
                "LineWidth", obj.NodeEdgeWidth )

            set( obj.NodeLabels, ...
                "FontSize", obj.NodeFontSize, ...
                "Visible", obj.NodeLabelsVisible )

            set( obj.LinkLabels, ...
                "FontSize", obj.LinkFontSize)

        end % update

    end % methods ( Access = protected )

end % classdef

function [XX, YY, CC] = wavyLink( startPoint, endPoint, ...
    girth, ratio, type, crossSection, n )
%WAVYLINK Compute the (x, y) coordinates and color of the wavy link
%connecting two nodes.

arguments ( Input )
    startPoint(1, 2) double
    endPoint(1, 2) double
    girth(1, 1) double {mustBeNonnegative, mustBeFinite}
    ratio(1, 3) double = [1, 1, 1]
    type(1, 1) string ...
        {mustBeMember( type, ["tanh", "cos", "line"] )} = "cos"
    crossSection(1, 1) string {mustBeMember( crossSection, ...
        ["normal", "vertical"] )} = "normal"
    n(1, 1) double {mustBeGreaterThan( n, 1 )} = 32
end % arguments ( Input )

width  = endPoint(1) - startPoint(1);
height = endPoint(2) - startPoint(2);

% Creating patch
if width > 0
    [XX, YY] = forwardLink();
else
    [XX, YY] = backwardsLink();
end % if

% Ensure simple (Jordan) polygons
warnID = "MATLAB:polyshape:repairedBySimplify";
warnState = warning( "query", warnID );
warning( "off", warnID )
warnCleanup = onCleanup( @() warning( warnState ) );
poly = polyshape( XX, YY );
poly = rmholes( poly );
XX = poly.Vertices(:, 1);
YY = poly.Vertices(:, 2);
NN = numel(XX);
CC = - abs( (2 * linspace( 0, NN, NN ) - NN ) / NN ) + 1;

    function [XX, YY] = forwardLink()

        % Creating reference function ([0,1] -> [0,1]) and derivative
        switch type
            case "tanh"
                curvy = 4;
                g  = @(x) (tanh( curvy * (2 * x - 1) ) + ...
                    tanh(curvy)) / (2 * tanh(curvy));
                dg = @(x) curvy * sech( curvy * ...
                    (2 * x - 1) ).^2 / tanh(curvy);
            case "cos"
                g  = @(x) (1 - cos( pi * x )) / 2;
                dg = @(x) pi * sin( pi * x ) /2;
            case "line"
                n = 2;
                g  = @(x) x;
                dg = @(x) ones( size( x ) );
        end % switch/case

        % Enabling vertical cross sections
        if crossSection == "vertical"
            dg = @(x) zeros( size( x ) );
        end % if

        % Scaling function to desired size
        f  = @(x) height * g( x / width );
        df = @(x) height * dg( x / width ) / width;

        % Computing reference line
        x0 = linspace( 0, width, n );
        y0 = f( x0 );

        % Computing normal vectors at each point
        rr = ratio(1) / ratio(2);
        delta = [df(x0); - ones( size( x0 ) ) / rr];
        delta = girth * diag( [rr, 1] ) * delta ./ vecnorm( delta ) / 2;

        % Taking points on each side of reference line
        x1 = x0 + delta(1, :);
        y1 = y0 + delta(2, :);

        x2 = x0 - delta(1, :);
        y2 = y0 - delta(2, :);

        % Cleaning up sides
        x1(1) = 0;
        x2(1) = 0;

        x1(end) = width;
        x2(end) = width;

        if width > 0
            before1 = x1 <= 0;
            before2 = x2 <= 0;
            after1  = x1 >= width;
            after2  = x2 >= width;
        else
            before1 = x1 >= 0;
            before2 = x2 >= 0;
            after1  = x1 <= width;
            after2  = x2 <= width;
        end % if

        x1(before1) = 0;
        y1(before1) = - girth / 2;

        x2(before2) = 0;
        y2(before2) = girth / 2;

        x1(after1) = width;
        y1(after1) = height - girth / 2;

        x2(after2) = width;
        y2(after2) = height + girth / 2;

        XX = startPoint(1) + [x1 fliplr(x2)];
        YY = startPoint(2) + [y1 fliplr(y2)] + girth / 2;

    end % forwardLink

    function [XX, YY] = backwardsLink()

        A = 0.1;
        B = A + girth * ratio(1) / ratio(2);
        C = -girth;
        if height < 0
            C = C + height;
        end

        XX = [0, A, A, width-A, width-A, width, ...
            width, width-B, width-B, B, B, 0];
        YY = [0, 0, C, C, height, height, ...
            height+girth, height+girth, C-girth, C-girth, girth, girth];

        XX = startPoint(1) + XX;
        YY = startPoint(2) + YY;

    end % backwardsLink

end % wavyLink
##### SOURCE END #####
-->
</body>
</html>
